<!DOCTYPE html>
































<html
  class="not-ready text-sm lg:text-base"
  style="--bg: #faf6f1"
  lang="zh-cn"
>
  <head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1, shrink-to-fit=no"
  />

  
  <title>ADB命令大全 - My Docs</title>

  
  <meta name="theme-color" />
  
  <meta name="description" content="ADB命令大全 Adb的全称为Android Debug Bridge：android调试桥梁，下图为Android官方对adb的介绍： 可以看出，Android的初衷是用adb这样的一个工具来协助开发人员在开发android应用的过程中更快更好的调试apk，因此adb具有安装卸载apk、拷贝推送文件、查看设备硬件信息、查看应用程序占用资源、在设备执行shell命令等功能；
我们可以在android sdk安装目录的platform-tools目录下找到adb工具；
现有安卓系统的权限机制越来越完善，很多希望能够绕开权限管理机制进行的一些操作都已经无法使用，但是Adb却可以实现。实际上Adb在某种程度上有很大权限的，即使是在最新版本的Android系统上。因为Adb的设计初衷是为了方便开发人员调试，因此必然需要暴露一些权限以外的接口。于是很多公司利用这个特性可以绕开权限机制在非Root非定制机上做一些操作（具体用法就是下面说的这些），当然方式也是五花八门，比如通过手机OTG连接，这里不再赘述。
ADB架构 为了方便理解，我们从三个指令入手，我们经常会用到adb start-server，adb devices,adb kill-server。 然后我们经常会看到这样的输出界面：
C:\Users\dell&gt;adb devicesList of devices attached* daemon not running. starting it now at tcp:5037 ** daemon started successfully * 于是这里有三点疑问，为什么是server，server对应的是服务器或者服务端吧？如果手机是客户端，服务端是不是指电脑上开启的服务。还有这个呆萌（daemon ）又是啥？
ADB是一个C/S架构的应用程序，由三部分组成：
运行在pc端的adb client： 命令行程序”adb”用于从shell或脚本中运行adb命令。首先，“adb”程序尝试定位主机上的ADB服务器，如果找不到ADB服务器，“adb”程序自动启动一个ADB服务器。接下来，当设备的adbd和pc端的adb server建立连接后，adb client就可以向ADB servcer发送服务请求； 运行在pc端的adb server： ADB Server是运行在主机上的一个后台进程。它的作用在于检测USB端口感知设备的连接和拔除，以及模拟器实例的启动或停止，ADB Server还需要将adb client的请求通过usb或者tcp的方式发送到对应的adbd上； 运行在设备端的常驻进程adb demon (adbd)： 程序“adbd”作为一个后台进程在Android设备或模拟器系统中运行。它的作用是连接ADB服务器，并且为运行在主机上的客户端提供一些服务； ADB端口被占用 有小伙伴说希望我把Adb启动问题放在最前面，因为他经常遇到adb找不到设备的问题，那我就放到前面吧，我想肯定不止是她一个人会遇到这种情况。
5037为adb默认端口，若5037端口被占用，则我们在使用Adb命令的时候会因为找不到设备而困扰，这个问题对于Adb不是很熟悉的小伙伴来说会经常遇到，因此我就把这个用法放在文章开头了，以便于小伙伴能方便找到； 解决这种端口占用的问题思路都是一样的，三步走：
找到使用该端口的进程Pid； C:\Windows\system32&gt;netstat -aon|findstr 5037 TCP 127.0.0.1:5037 0.0.0.0:0 LISTENING 3172 12 通过PID找到对应的进程名（便于定位，可以跳过）； C:\Windows\system32&gt;tasklist /fi &#34;PID eq 3172&#34; 映像名称 PID 会话名 会话# 内存使用 ========================= ======== ================ =========== ============ 360MobileLink." />
  <meta
    name="author"
    content=""
  />
  

  
  
  
  
  
  
  <link rel="preload stylesheet" as="style" href="http://localhost/main.min.css" />

  
  <script
    defer
    src="http://localhost/highlight.min.js"
    onload="hljs.initHighlightingOnLoad();"
  ></script>
  

  
     
  <link rel="preload" as="image" href="http://localhost/theme.png" />

  
  
  
  <link rel="preload" as="image" href="https://deno.land/logo.svg" />
  
  

  
  <link rel="preload" as="image" href="http://localhost/twitter.svg" />
  
  <link rel="preload" as="image" href="http://localhost/github.svg" />
  

  
  <link rel="icon" href="http://localhost/favicon.ico" />
  <link rel="apple-touch-icon" href="http://localhost/apple-touch-icon.png" />

  
  <meta name="generator" content="Hugo 0.108.0">

  
  

  
  
  
  
  
  
  
  
  
  <meta property="og:title" content="ADB命令大全" />
<meta property="og:description" content="ADB命令大全 Adb的全称为Android Debug Bridge：android调试桥梁，下图为Android官方对adb的介绍： 可以看出，Android的初衷是用adb这样的一个工具来协助开发人员在开发android应用的过程中更快更好的调试apk，因此adb具有安装卸载apk、拷贝推送文件、查看设备硬件信息、查看应用程序占用资源、在设备执行shell命令等功能；
我们可以在android sdk安装目录的platform-tools目录下找到adb工具；
现有安卓系统的权限机制越来越完善，很多希望能够绕开权限管理机制进行的一些操作都已经无法使用，但是Adb却可以实现。实际上Adb在某种程度上有很大权限的，即使是在最新版本的Android系统上。因为Adb的设计初衷是为了方便开发人员调试，因此必然需要暴露一些权限以外的接口。于是很多公司利用这个特性可以绕开权限机制在非Root非定制机上做一些操作（具体用法就是下面说的这些），当然方式也是五花八门，比如通过手机OTG连接，这里不再赘述。
ADB架构 为了方便理解，我们从三个指令入手，我们经常会用到adb start-server，adb devices,adb kill-server。 然后我们经常会看到这样的输出界面：
C:\Users\dell&gt;adb devicesList of devices attached* daemon not running. starting it now at tcp:5037 ** daemon started successfully * 于是这里有三点疑问，为什么是server，server对应的是服务器或者服务端吧？如果手机是客户端，服务端是不是指电脑上开启的服务。还有这个呆萌（daemon ）又是啥？
ADB是一个C/S架构的应用程序，由三部分组成：
运行在pc端的adb client： 命令行程序”adb”用于从shell或脚本中运行adb命令。首先，“adb”程序尝试定位主机上的ADB服务器，如果找不到ADB服务器，“adb”程序自动启动一个ADB服务器。接下来，当设备的adbd和pc端的adb server建立连接后，adb client就可以向ADB servcer发送服务请求； 运行在pc端的adb server： ADB Server是运行在主机上的一个后台进程。它的作用在于检测USB端口感知设备的连接和拔除，以及模拟器实例的启动或停止，ADB Server还需要将adb client的请求通过usb或者tcp的方式发送到对应的adbd上； 运行在设备端的常驻进程adb demon (adbd)： 程序“adbd”作为一个后台进程在Android设备或模拟器系统中运行。它的作用是连接ADB服务器，并且为运行在主机上的客户端提供一些服务； ADB端口被占用 有小伙伴说希望我把Adb启动问题放在最前面，因为他经常遇到adb找不到设备的问题，那我就放到前面吧，我想肯定不止是她一个人会遇到这种情况。
5037为adb默认端口，若5037端口被占用，则我们在使用Adb命令的时候会因为找不到设备而困扰，这个问题对于Adb不是很熟悉的小伙伴来说会经常遇到，因此我就把这个用法放在文章开头了，以便于小伙伴能方便找到； 解决这种端口占用的问题思路都是一样的，三步走：
找到使用该端口的进程Pid； C:\Windows\system32&gt;netstat -aon|findstr 5037 TCP 127.0.0.1:5037 0.0.0.0:0 LISTENING 3172 12 通过PID找到对应的进程名（便于定位，可以跳过）； C:\Windows\system32&gt;tasklist /fi &#34;PID eq 3172&#34; 映像名称 PID 会话名 会话# 内存使用 ========================= ======== ================ =========== ============ 360MobileLink." />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://localhost/posts/adb%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-12-08T14:16:10+08:00" />
<meta property="article:modified_time" content="2022-12-08T14:16:10+08:00" />

  
  <meta itemprop="name" content="ADB命令大全">
<meta itemprop="description" content="ADB命令大全 Adb的全称为Android Debug Bridge：android调试桥梁，下图为Android官方对adb的介绍： 可以看出，Android的初衷是用adb这样的一个工具来协助开发人员在开发android应用的过程中更快更好的调试apk，因此adb具有安装卸载apk、拷贝推送文件、查看设备硬件信息、查看应用程序占用资源、在设备执行shell命令等功能；
我们可以在android sdk安装目录的platform-tools目录下找到adb工具；
现有安卓系统的权限机制越来越完善，很多希望能够绕开权限管理机制进行的一些操作都已经无法使用，但是Adb却可以实现。实际上Adb在某种程度上有很大权限的，即使是在最新版本的Android系统上。因为Adb的设计初衷是为了方便开发人员调试，因此必然需要暴露一些权限以外的接口。于是很多公司利用这个特性可以绕开权限机制在非Root非定制机上做一些操作（具体用法就是下面说的这些），当然方式也是五花八门，比如通过手机OTG连接，这里不再赘述。
ADB架构 为了方便理解，我们从三个指令入手，我们经常会用到adb start-server，adb devices,adb kill-server。 然后我们经常会看到这样的输出界面：
C:\Users\dell&gt;adb devicesList of devices attached* daemon not running. starting it now at tcp:5037 ** daemon started successfully * 于是这里有三点疑问，为什么是server，server对应的是服务器或者服务端吧？如果手机是客户端，服务端是不是指电脑上开启的服务。还有这个呆萌（daemon ）又是啥？
ADB是一个C/S架构的应用程序，由三部分组成：
运行在pc端的adb client： 命令行程序”adb”用于从shell或脚本中运行adb命令。首先，“adb”程序尝试定位主机上的ADB服务器，如果找不到ADB服务器，“adb”程序自动启动一个ADB服务器。接下来，当设备的adbd和pc端的adb server建立连接后，adb client就可以向ADB servcer发送服务请求； 运行在pc端的adb server： ADB Server是运行在主机上的一个后台进程。它的作用在于检测USB端口感知设备的连接和拔除，以及模拟器实例的启动或停止，ADB Server还需要将adb client的请求通过usb或者tcp的方式发送到对应的adbd上； 运行在设备端的常驻进程adb demon (adbd)： 程序“adbd”作为一个后台进程在Android设备或模拟器系统中运行。它的作用是连接ADB服务器，并且为运行在主机上的客户端提供一些服务； ADB端口被占用 有小伙伴说希望我把Adb启动问题放在最前面，因为他经常遇到adb找不到设备的问题，那我就放到前面吧，我想肯定不止是她一个人会遇到这种情况。
5037为adb默认端口，若5037端口被占用，则我们在使用Adb命令的时候会因为找不到设备而困扰，这个问题对于Adb不是很熟悉的小伙伴来说会经常遇到，因此我就把这个用法放在文章开头了，以便于小伙伴能方便找到； 解决这种端口占用的问题思路都是一样的，三步走：
找到使用该端口的进程Pid； C:\Windows\system32&gt;netstat -aon|findstr 5037 TCP 127.0.0.1:5037 0.0.0.0:0 LISTENING 3172 12 通过PID找到对应的进程名（便于定位，可以跳过）； C:\Windows\system32&gt;tasklist /fi &#34;PID eq 3172&#34; 映像名称 PID 会话名 会话# 内存使用 ========================= ======== ================ =========== ============ 360MobileLink."><meta itemprop="datePublished" content="2022-12-08T14:16:10+08:00" />
<meta itemprop="dateModified" content="2022-12-08T14:16:10+08:00" />
<meta itemprop="wordCount" content="4266">
<meta itemprop="keywords" content="" />
  
  <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="ADB命令大全"/>
<meta name="twitter:description" content="ADB命令大全 Adb的全称为Android Debug Bridge：android调试桥梁，下图为Android官方对adb的介绍： 可以看出，Android的初衷是用adb这样的一个工具来协助开发人员在开发android应用的过程中更快更好的调试apk，因此adb具有安装卸载apk、拷贝推送文件、查看设备硬件信息、查看应用程序占用资源、在设备执行shell命令等功能；
我们可以在android sdk安装目录的platform-tools目录下找到adb工具；
现有安卓系统的权限机制越来越完善，很多希望能够绕开权限管理机制进行的一些操作都已经无法使用，但是Adb却可以实现。实际上Adb在某种程度上有很大权限的，即使是在最新版本的Android系统上。因为Adb的设计初衷是为了方便开发人员调试，因此必然需要暴露一些权限以外的接口。于是很多公司利用这个特性可以绕开权限机制在非Root非定制机上做一些操作（具体用法就是下面说的这些），当然方式也是五花八门，比如通过手机OTG连接，这里不再赘述。
ADB架构 为了方便理解，我们从三个指令入手，我们经常会用到adb start-server，adb devices,adb kill-server。 然后我们经常会看到这样的输出界面：
C:\Users\dell&gt;adb devicesList of devices attached* daemon not running. starting it now at tcp:5037 ** daemon started successfully * 于是这里有三点疑问，为什么是server，server对应的是服务器或者服务端吧？如果手机是客户端，服务端是不是指电脑上开启的服务。还有这个呆萌（daemon ）又是啥？
ADB是一个C/S架构的应用程序，由三部分组成：
运行在pc端的adb client： 命令行程序”adb”用于从shell或脚本中运行adb命令。首先，“adb”程序尝试定位主机上的ADB服务器，如果找不到ADB服务器，“adb”程序自动启动一个ADB服务器。接下来，当设备的adbd和pc端的adb server建立连接后，adb client就可以向ADB servcer发送服务请求； 运行在pc端的adb server： ADB Server是运行在主机上的一个后台进程。它的作用在于检测USB端口感知设备的连接和拔除，以及模拟器实例的启动或停止，ADB Server还需要将adb client的请求通过usb或者tcp的方式发送到对应的adbd上； 运行在设备端的常驻进程adb demon (adbd)： 程序“adbd”作为一个后台进程在Android设备或模拟器系统中运行。它的作用是连接ADB服务器，并且为运行在主机上的客户端提供一些服务； ADB端口被占用 有小伙伴说希望我把Adb启动问题放在最前面，因为他经常遇到adb找不到设备的问题，那我就放到前面吧，我想肯定不止是她一个人会遇到这种情况。
5037为adb默认端口，若5037端口被占用，则我们在使用Adb命令的时候会因为找不到设备而困扰，这个问题对于Adb不是很熟悉的小伙伴来说会经常遇到，因此我就把这个用法放在文章开头了，以便于小伙伴能方便找到； 解决这种端口占用的问题思路都是一样的，三步走：
找到使用该端口的进程Pid； C:\Windows\system32&gt;netstat -aon|findstr 5037 TCP 127.0.0.1:5037 0.0.0.0:0 LISTENING 3172 12 通过PID找到对应的进程名（便于定位，可以跳过）； C:\Windows\system32&gt;tasklist /fi &#34;PID eq 3172&#34; 映像名称 PID 会话名 会话# 内存使用 ========================= ======== ================ =========== ============ 360MobileLink."/>

  
  
</head>

  <body class="text-black duration-200 ease-out dark:text-white">
    <header class="mx-auto flex h-[5rem] max-w-3xl px-8 lg:justify-center">
  <div class="relative z-50 mr-auto flex items-center">
    <a
      class="-translate-x-[1px] -translate-y-0.5 text-3xl font-bold"
      href="http://localhost/"
      >My Docs</a
    >
    <a
      class="btn-dark ml-6 h-6 w-6 shrink-0 cursor-pointer [background:url(./theme.svg)_left_center/cover_no-repeat] dark:invert dark:[background-position:right]"
    ></a>
  </div>

  <a
    class="btn-menu relative z-50 -mr-8 flex h-[5rem] w-[5rem] shrink-0 cursor-pointer flex-col items-center justify-center gap-2.5 lg:hidden"
  ></a>

  
  <script>
    
    const htmlClass = document.documentElement.classList;
    setTimeout(() => {
      htmlClass.remove('not-ready');
    }, 10);

    
    const btnMenu = document.querySelector('.btn-menu');
    btnMenu.addEventListener('click', () => {
      htmlClass.toggle('open');
    });

    
    const metaTheme = document.querySelector('meta[name="theme-color"]');
    const lightBg = `"#faf6f1"`.replace(/"/g, '');
    const setDark = (isDark) => {
      metaTheme.setAttribute('content', isDark ? '#000' : lightBg);
      htmlClass[isDark ? 'add' : 'remove']('dark');
      localStorage.setItem('dark', isDark);
    };

    
    const darkScheme = window.matchMedia('(prefers-color-scheme: dark)');
    if (htmlClass.contains('dark')) {
      setDark(true);
    } else {
      const darkVal = localStorage.getItem('dark');
      setDark(darkVal ? darkVal === 'true' : darkScheme.matches);
    }

    
    darkScheme.addEventListener('change', (event) => {
      setDark(event.matches);
    });

    
    const btnDark = document.querySelector('.btn-dark');
    btnDark.addEventListener('click', () => {
      setDark(localStorage.getItem('dark') !== 'true');
    });
  </script>

  <div
    class="nav-wrapper fixed inset-x-0 top-full z-40 flex h-full select-none flex-col justify-center pb-16 duration-200 dark:bg-black lg:static lg:h-auto lg:flex-row lg:!bg-transparent lg:pb-0 lg:transition-none"
  >
    
    

    
    <nav
      class="mt-12 flex justify-center space-x-10 dark:invert lg:mt-0 lg:ml-12 lg:items-center lg:space-x-6"
    >
      
      <a
        class="h-8 w-8 [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6"
        style="--url: url(./twitter.svg)"
        href=" https://twitter.com/dsumuzhe "
        target="_blank"
      ></a>
      
      <a
        class="h-8 w-8 [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6"
        style="--url: url(./github.svg)"
        href=" https://github.com/renchangjiu "
        target="_blank"
      ></a>
      
    </nav>
    
  </div>
</header>


    <main
      class="prose prose-neutral relative mx-auto min-h-[calc(100%-10rem)] max-w-3xl px-8 pt-20 pb-32 dark:prose-invert"
    >
      

<article>
  <header class="mb-20">
    <h1 class="!my-0 pb-2.5">ADB命令大全</h1>

    
    <div class="text-sm opacity-60">
      
      <time>Dec 8, 2022</time>
      
      
    </div>
    
  </header>

  <section><h1 id="adb命令大全">ADB命令大全</h1>
<hr>
<p>Adb的全称为Android Debug Bridge：android调试桥梁，下图为Android官方对adb的介绍：
<img src="https://img-blog.csdnimg.cn/20190620094906531.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pob25nbHVuc2h1bg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">
可以看出，Android的初衷是用adb这样的一个工具来协助开发人员在开发android应用的过程中更快更好的调试apk，因此adb具有安装卸载apk、拷贝推送文件、查看设备硬件信息、查看应用程序占用资源、在设备执行shell命令等功能；</p>
<p>我们可以在android sdk安装目录的platform-tools目录下找到adb工具；</p>
<p>现有安卓系统的权限机制越来越完善，很多希望能够绕开权限管理机制进行的一些操作都已经无法使用，但是Adb却可以实现。实际上Adb在某种程度上有很大权限的，即使是在最新版本的Android系统上。因为Adb的设计初衷是为了方便开发人员调试，因此必然需要暴露一些权限以外的接口。于是很多公司利用这个特性可以<strong>绕开权限机制</strong>在非Root非定制机上做一些操作（具体用法就是下面说的这些），当然方式也是五花八门，比如通过手机OTG连接，这里不再赘述。</p>
<h2 id="adb架构">ADB架构</h2>
<p>为了方便理解，我们从三个指令入手，我们经常会用到adb start-server，adb devices,adb kill-server。
然后我们经常会看到这样的输出界面：</p>
<pre tabindex="0"><code>C:\Users\dell&gt;adb devices
List of devices attached
* daemon not running. starting it now at tcp:5037 *
* daemon started successfully *
</code></pre><p>于是这里有三点疑问，为什么是server，server对应的是服务器或者服务端吧？如果手机是客户端，服务端是不是指电脑上开启的服务。还有这个呆萌（daemon ）又是啥？</p>
<p>ADB是一个C/S架构的应用程序，由三部分组成：</p>
<ol>
<li>运行在pc端的adb client：
命令行程序”adb”用于从shell或脚本中运行adb命令。首先，“adb”程序尝试定位主机上的ADB服务器，如果找不到ADB服务器，“adb”程序自动启动一个ADB服务器。接下来，当设备的adbd和pc端的adb server建立连接后，adb client就可以向ADB servcer发送服务请求；</li>
<li>运行在pc端的adb server：
ADB Server是运行在主机上的一个后台进程。它的作用在于检测USB端口感知设备的连接和拔除，以及模拟器实例的启动或停止，ADB Server还需要将adb client的请求通过usb或者tcp的方式发送到对应的adbd上；</li>
<li>运行在设备端的常驻进程adb demon (adbd)：
程序“adbd”作为一个后台进程在Android设备或模拟器系统中运行。它的作用是连接ADB服务器，并且为运行在主机上的客户端提供一些服务；</li>
</ol>
<h2 id="在这里插入图片描述httpsimg-blogcsdnimgcn20190620094923717pngx-oss-processimagewatermarktype_zmfuz3pozw5nagvpdgkshadow_10text_ahr0chm6ly9ibg9nlmnzzg4ubmv0l3pob25nbhvuc2h1bgsize_16color_fffffft_70"><img src="https://img-blog.csdnimg.cn/20190620094923717.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pob25nbHVuc2h1bg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></h2>
<p><img src="https://img-blog.csdnimg.cn/20190620094933317.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pob25nbHVuc2h1bg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="adb端口被占用">ADB端口被占用</h2>
<p>有小伙伴说希望我把Adb启动问题放在最前面，因为他经常遇到adb找不到设备的问题，那我就放到前面吧，我想肯定不止是她一个人会遇到这种情况。</p>
<p>5037为adb默认端口，若5037端口被占用，则我们在使用Adb命令的时候会因为找不到设备而困扰，这个问题对于Adb不是很熟悉的小伙伴来说会经常遇到，因此我就把这个用法放在文章开头了，以便于小伙伴能方便找到；
解决这种端口占用的问题思路都是一样的，三步走：</p>
<ol>
<li>找到使用该端口的进程Pid；</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>C:<span style="color:#ae81ff">\W</span>indows<span style="color:#ae81ff">\s</span>ystem32&gt;netstat -aon|findstr <span style="color:#ae81ff">5037</span>
</span></span><span style="display:flex;"><span>TCP    127.0.0.1:5037         0.0.0.0:0              LISTENING       <span style="color:#ae81ff">3172</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">12</span>
</span></span></code></pre></div><ol>
<li>通过PID找到对应的进程名（便于定位，可以跳过）；</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>C:<span style="color:#ae81ff">\W</span>indows<span style="color:#ae81ff">\s</span>ystem32&gt;tasklist /fi <span style="color:#e6db74">&#34;PID eq 3172&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>映像名称                       PID 会话名              会话#       内存使用
</span></span><span style="display:flex;"><span><span style="color:#f92672">=========================</span> <span style="color:#f92672">========</span> <span style="color:#f92672">================</span> <span style="color:#f92672">===========</span> <span style="color:#f92672">============</span>
</span></span><span style="display:flex;"><span>360MobileLink.exe             <span style="color:#ae81ff">3172</span> Console                    <span style="color:#ae81ff">4</span>     40,208 K
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">12345</span>
</span></span></code></pre></div><ol>
<li>使用命令终止该命令的运行；</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>C:<span style="color:#ae81ff">\U</span>sers<span style="color:#ae81ff">\w</span>wx229495&gt;taskkill /pid <span style="color:#ae81ff">3172</span> /f
</span></span><span style="display:flex;"><span>成功: 已终止 PID 为 <span style="color:#ae81ff">3172</span> 的进程。
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">12</span>
</span></span></code></pre></div><blockquote>
<p>有些时候，一些流氓程序会复制一份Adb.exe到windows环境变量中，比如C://Windows/system32，这个时候我们可以使用Where
Adb 命令找出来adb所在的路径并删除。</p>
</blockquote>
<h2 id="基本用法">基本用法</h2>
<hr>
<p>adb能做什么?答案是所有能对手机的操作都能用adb实现。也就是说如果你玩的6，你就是触摸屏完全坏了，显示屏完全坏了，就只是给你一个主板，你照样能完成你要做的动作。当然在一般场景不推荐这样做，效率优先嘛。</p>
<p>接下来的内容是转自github上一位大牛的<a href="https://github.com/mzlogin/awesome-adb">博客</a>，如有侵权请告知，立即删除；
后期</p>
<h3 id="命令语法">命令语法</h3>
<p>adb 命令的基本语法如下：</p>
<blockquote>
<p>adb [-d|-e|-s ]</p>
</blockquote>
<p>如果只有一个设备/模拟器连接时，可以省略掉 [-d|-e|-s ] 这一部分，直接使用 adb 。</p>
<h3 id="为命令指定目标设备">为命令指定目标设备</h3>
<p>如果有多个设备/模拟器连接，则需要为命令指定目标设备。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>-d</td>
<td>指定当前唯一通过 USB 连接的 Android 设备为命令目标</td>
</tr>
<tr>
<td>-e</td>
<td>指定当前唯一运行的模拟器为命令目标</td>
</tr>
<tr>
<td><code>-s &lt;serialNumber&gt;</code></td>
<td>指定相应 serialNumber 号的设备/模拟器为命令目标</td>
</tr>
</tbody>
</table>
<p>在多个设备/模拟器连接的情况下较常用的是 -s 参数，serialNumber 可以通过 adb devices 命令获取。如：</p>
<pre tabindex="0"><code>$ adb devices

List of devices attached
cf264b8f	device
emulator-5554	device
10.129.164.6:5555	device
123456
</code></pre><p>输出里的 cf264b8f、emulator-5554 和 10.129.164.6:5555 即为 serialNumber。</p>
<p>比如这时想指定 cf264b8f 这个设备来运行 adb 命令获取屏幕分辨率：</p>
<pre tabindex="0"><code>adb -s cf264b8f shell wm size
1
</code></pre><p>又如想给 10.129.164.6:5555 这个设备安装应用（这种形式的 serialNumber 格式为 :，一般为无线连接的设备或 Genymotion 等第三方 Android 模拟器）：</p>
<pre tabindex="0"><code>adb -s 10.129.164.6:5555 install test.apk
1
</code></pre><p><em>遇到多设备/模拟器的情况均使用这几个参数为命令指定目标设备，下文中为简化描述，不再重复。</em></p>
<h3 id="启动停止">启动/停止</h3>
<p>启动 adb server 命令：</p>
<pre tabindex="0"><code>adb start-server
1
</code></pre><p>（一般无需手动执行此命令，在运行 adb 命令时若发现 adb server 没有启动会自动调起。）</p>
<p>停止 adb server 命令：</p>
<pre tabindex="0"><code>adb kill-server
1
</code></pre><h3 id="查看-adb-版本">查看 adb 版本</h3>
<pre tabindex="0"><code>adb version
1
</code></pre><p>示例输出</p>
<pre tabindex="0"><code>Android Debug Bridge version 1.0.36
Revision 8f855a3d9b35-android
12
</code></pre><h3 id="以-root-权限运行-adbd">以 root 权限运行 adbd</h3>
<p>adb 的运行原理是 PC 端的 adb server 与手机端的守护进程 adbd 建立连接，然后 PC 端的 adb client 通过 adb server 转发命令，adbd 接收命令后解析运行。</p>
<p>所以如果 adbd 以普通权限执行，有些需要 root 权限才能执行的命令无法直接用 adb xxx 执行。这时可以 adb shell 然后 su 后执行命令，也可以让 adbd 以 root 权限执行，这个就能随意执行高权限命令了。</p>
<p>命令：</p>
<pre tabindex="0"><code>adb root
1
</code></pre><p>正常输出：</p>
<pre tabindex="0"><code>restarting adbd as root
1
</code></pre><p>现在再运行 adb shell，看看命令行提示符是不是变成 # 了？</p>
<p>有些手机 root 后也无法通过 adb root 命令让 adbd 以 root 权限执行，比如三星的部分机型，会提示 adbd cannot run as root in production builds，此时可以先安装 <strong>adbd Insecure</strong>，然后 adb root 试试。</p>
<p>相应地，如果要恢复 adbd 为非 root 权限的话，可以使用 <strong>adb unroot</strong> 命令。</p>
<h3 id="指定-adb-server-的网络端口">指定 adb server 的网络端口</h3>
<pre tabindex="0"><code>adb -P &lt;port&gt; start-server
1
</code></pre><p>默认端口为 5037。</p>
<h2 id="设备连接管理">设备连接管理</h2>
<hr>
<h3 id="查询已连接设备模拟器">查询已连接设备/模拟器</h3>
<p>命令：</p>
<pre tabindex="0"><code>adb devices
1
</code></pre><p>输出示例：</p>
<pre tabindex="0"><code>List of devices attached
cf264b8f	device
emulator-5554	device
10.129.164.6:5555	device
1234
</code></pre><p>输出格式为 [serialNumber] [state]，serialNumber 即我们常说的 SN，state 有如下几种：</p>
<p>offline —— 表示设备未连接成功或无响应。</p>
<p>device —— 设备已连接。注意这个状态并不能标识 Android 系统已经完全启动和可操作，在设备启动过程中设备实例就可连接到 adb，但启动完毕后系统才处于可操作状态。</p>
<p>no device —— 没有设备/模拟器连接。</p>
<p>以上输出显示当前已经连接了三台设备/模拟器，cf264b8f、emulator-5554 和 10.129.164.6:5555 分别是它们的 SN。从 emulator-5554 这个名字可以看出它是一个 Android 模拟器，而 10.129.164.6:5555 这种形为 : 的 serialNumber 一般是无线连接的设备或 Genymotion 等第三方 Android 模拟器。</p>
<p>常见异常输出：</p>
<p>没有设备/模拟器连接成功。</p>
<p>List of devices attached
设备/模拟器未连接到 adb 或无响应。</p>
<p>List of devices attached
cf264b8f offline</p>
<h3 id="usb-连接">USB 连接</h3>
<p>通过 USB 连接来正常使用 adb 需要保证几点：</p>
<p>硬件状态正常。</p>
<p>包括 Android 设备处于正常开机状态，USB 连接线和各种接口完好。</p>
<p>Android 设备的开发者选项和 USB 调试模式已开启。</p>
<p>可以到「设置」-「开发者选项」-「Android 调试」查看。</p>
<p>如果在设置里找不到开发者选项，那需要通过一个彩蛋来让它显示出来：在「设置」-「关于手机」连续点击「版本号」7 次。</p>
<p>设备驱动状态正常。</p>
<p>这一点貌似在 Linux 和 Mac OS X 下不用操心，在 Windows 下有可能遇到需要安装驱动的情况，确认这一点可以右键「计算机」-「属性」，到「设备管理器」里查看相关设备上是否有黄色感叹号或问号，如果没有就说明驱动状态已经好了。否则可以下载一个手机助手类程序来安装驱动先。</p>
<p>通过 USB 线连接好电脑和设备后确认状态。</p>
<pre tabindex="0"><code>adb devices
1
</code></pre><p>如果能看到
xxxxxx device
说明连接成功。</p>
<h3 id="无线连接需要借助-usb-线">无线连接（需要借助 USB 线）</h3>
<p>除了可以通过 USB 连接设备与电脑来使用 adb，也可以通过无线连接——虽然连接过程中也有需要使用 USB 的步骤，但是连接成功之后你的设备就可以在一定范围内摆脱 USB 连接线的限制啦！</p>
<p>操作步骤：
将 Android 设备与要运行 adb 的电脑连接到同一个局域网，比如连到同一个 WiFi。
将设备与电脑通过 USB 线连接。
应确保连接成功（可运行 adb devices 看是否能列出该设备）。
让设备在 5555 端口监听 TCP/IP 连接：</p>
<pre tabindex="0"><code>adb tcpip 5555
1
</code></pre><p>断开 USB 连接。
找到设备的 IP 地址。
一般能在「设置」-「关于手机」-「状态信息」-「IP地址」找到，也可以使用下文里 查看设备信息 - IP 地址 一节里的方法用 adb 命令来查看。</p>
<p>通过 IP 地址连接设备。</p>
<pre tabindex="0"><code>adb connect &lt;device-ip-address&gt;
1
</code></pre><p>这里的 就是上一步中找到的设备 IP 地址。</p>
<p>确认连接状态。</p>
<pre tabindex="0"><code>adb devices
1
</code></pre><p>如果能看到</p>
<pre tabindex="0"><code>&lt;device-ip-address&gt;:5555 device
1
</code></pre><p>说明连接成功。
如果连接不了，请确认 Android 设备与电脑是连接到了同一个 WiFi，然后再次执行 <code>adb connect &lt;device-ip-address&gt;</code> 那一步；
如果还是不行的话，通过 adb kill-server 重新启动 adb 然后从头再来一次试试。</p>
<p>断开无线连接
命令：</p>
<pre tabindex="0"><code>adb disconnect &lt;device-ip-address&gt;
1
</code></pre><h3 id="无线连接无需借助-usb-线">无线连接（无需借助 USB 线）</h3>
<p>注：需要 root 权限。</p>
<p>上一节「无线连接（需要借助 USB 线）」是官方文档里介绍的方法，需要借助于 USB 数据线来实现无线连接。
既然我们想要实现无线连接，那能不能所有步骤下来都是无线的呢？答案是能的。
在 Android 设备上安装一个终端模拟器。
已经安装过的设备可以跳过此步。我使用的终端模拟器下载地址是：Terminal Emulator for Android Downloads
将 Android 设备与要运行 adb 的电脑连接到同一个局域网，比如连到同一个 WiFi。
打开 Android 设备上的终端模拟器，在里面依次运行命令：</p>
<pre tabindex="0"><code>su
setprop service.adb.tcp.port 5555
12
</code></pre><p>找到 Android 设备的 IP 地址。</p>
<p>一般能在「设置」-「关于手机」-「状态信息」-「IP地址」找到，也可以使用下文里 查看设备信息 - IP 地址 一节里的方法用 adb 命令来查看。</p>
<p>在电脑上通过 adb 和 IP 地址连接 Android 设备。</p>
<pre tabindex="0"><code>adb connect &lt;device-ip-address&gt;
1
</code></pre><p>这里的 就是上一步中找到的设备 IP 地址。</p>
<p>如果能看到 connected to :5555 这样的输出则表示连接成功。</p>
<p><strong>节注一：</strong></p>
<p>有的设备，比如小米 5S + MIUI 8.0 + Android 6.0.1 MXB48T，可能在第 5 步之前需要重启 adbd 服务，在设备的终端模拟器上运行：</p>
<pre tabindex="0"><code>restart adbd
1
</code></pre><p>如果 restart 无效，尝试以下命令：</p>
<pre tabindex="0"><code>stop adbd
start adbd
12
</code></pre><h2 id="应用管理">应用管理</h2>
<h3 id="查看应用列表">查看应用列表</h3>
<p>查看应用列表的基本命令格式是</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>adb shell pm list packages <span style="color:#f92672">[</span>-f<span style="color:#f92672">]</span> <span style="color:#f92672">[</span>-d<span style="color:#f92672">]</span> <span style="color:#f92672">[</span>-e<span style="color:#f92672">]</span> <span style="color:#f92672">[</span>-s<span style="color:#f92672">]</span> <span style="color:#f92672">[</span>-3<span style="color:#f92672">]</span> <span style="color:#f92672">[</span>-i<span style="color:#f92672">]</span> <span style="color:#f92672">[</span>-u<span style="color:#f92672">]</span> <span style="color:#f92672">[</span>--user USER_ID<span style="color:#f92672">]</span> <span style="color:#f92672">[</span>FILTER<span style="color:#f92672">]</span>
</span></span></code></pre></div><p>即在 adb shell pm list packages 的基础上可以加一些参数进行过滤查看不同的列表，支持的过滤参数如下：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>显示列表</th>
</tr>
</thead>
<tbody>
<tr>
<td>无</td>
<td>所有应用</td>
</tr>
<tr>
<td>-f</td>
<td>显示应用关联的 apk 文件</td>
</tr>
<tr>
<td>-d</td>
<td>只显示 disabled 的应用</td>
</tr>
<tr>
<td>-e</td>
<td>只显示 enabled 的应用</td>
</tr>
<tr>
<td>-s</td>
<td>只显示系统应用</td>
</tr>
<tr>
<td>-3</td>
<td>只显示第三方应用</td>
</tr>
<tr>
<td>-i</td>
<td>显示应用的 installer</td>
</tr>
<tr>
<td>-u</td>
<td>包含已卸载应用</td>
</tr>
<tr>
<td><code>&lt;FILTER&gt;</code></td>
<td>包名包含 <code>&lt;FILTER&gt;</code> 字符串</td>
</tr>
</tbody>
</table>
<h3 id="所有应用">所有应用</h3>
<p>命令：</p>
<pre tabindex="0"><code>adb shell pm list packages
1
</code></pre><p>输出示例：</p>
<pre tabindex="0"><code>package:com.android.smoketest
package:com.example.android.livecubes
package:com.android.providers.telephony
package:com.google.android.googlequicksearchbox
package:com.android.providers.calendar
package:com.android.providers.media
package:com.android.protips
package:com.android.documentsui
package:com.android.gallery
package:com.android.externalstorage
...
// other packages here
...
12345678910111213
</code></pre><h3 id="系统应用">系统应用</h3>
<p>命令：</p>
<pre tabindex="0"><code>adb shell pm list packages -s
1
</code></pre><h3 id="第三方应用">第三方应用</h3>
<p>命令：</p>
<pre tabindex="0"><code>adb shell pm list packages -3
1
</code></pre><p>包名包含某字符串的应用
比如要查看包名包含字符串 mazhuang 的应用列表，命令：</p>
<pre tabindex="0"><code>adb shell pm list packages mazhuang
1
</code></pre><p>当然也可以使用 grep 来过滤：</p>
<pre tabindex="0"><code>adb shell pm list packages | grep mazhuang
1
</code></pre><h3 id="安装-apk">安装 APK</h3>
<p>命令格式：</p>
<pre tabindex="0"><code>adb install [-lrtsdg] &lt;path_to_apk&gt;
</code></pre><p>参数：</p>
<p>adb install 后面可以跟一些可选参数来控制安装 APK 的行为，可用参数及含义如下：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>-l</td>
<td>将应用安装到保护目录 /mnt/asec</td>
</tr>
<tr>
<td>-r</td>
<td>允许覆盖安装</td>
</tr>
<tr>
<td>-t</td>
<td>允许安装 AndroidManifest.xml 里 application 指定 <code>android:testOnly=&quot;true&quot;</code> 的应用</td>
</tr>
<tr>
<td>-s</td>
<td>将应用安装到 sdcard</td>
</tr>
<tr>
<td>-d</td>
<td>允许降级覆盖安装</td>
</tr>
<tr>
<td>-g</td>
<td>授予所有运行时权限</td>
</tr>
</tbody>
</table>
<p>运行命令后如果见到类似如下输出（状态为 Success）代表安装成功：</p>
<pre tabindex="0"><code>[100%] /data/local/tmp/1.apk
	pkg: /data/local/tmp/1.apk
Success
</code></pre><p>上面是当前最新版 v1.0.36 的 adb 的输出，会显示 push apk 文件到手机的进度百分比。</p>
<p>使用旧版本 adb 的输出则是这样的：</p>
<pre tabindex="0"><code>12040 KB/s (22205609 bytes in 1.801s)
        pkg: /data/local/tmp/SogouInput_android_v8.3_sweb.apk
Success
12
</code></pre><p>而如果状态为 Failure 则表示安装失败，比如：</p>
<pre tabindex="0"><code>[100%] /data/local/tmp/map-20160831.apk
        pkg: /data/local/tmp/map-20160831.apk
Failure [INSTALL_FAILED_ALREADY_EXISTS]
123
</code></pre><p>常见安装失败输出代码、含义及可能的解决办法如下：</p>
<table>
<thead>
<tr>
<th>输出</th>
<th>含义</th>
<th>解决办法</th>
</tr>
</thead>
<tbody>
<tr>
<td>INSTALL_FAILED_ALREADY_EXISTS</td>
<td>应用已经存在，或卸载了但没卸载干净</td>
<td><code>adb install</code> 时使用 <code>-r</code> 参数，或者先 <code>adb uninstall &lt;packagename&gt;</code> 再安装</td>
</tr>
<tr>
<td>INSTALL_FAILED_INVALID_APK</td>
<td>无效的 APK 文件</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_INVALID_URI</td>
<td>无效的 APK 文件名</td>
<td>确保 APK 文件名里无中文</td>
</tr>
<tr>
<td>INSTALL_FAILED_INSUFFICIENT_STORAGE</td>
<td>空间不足</td>
<td>清理空间</td>
</tr>
<tr>
<td>INSTALL_FAILED_DUPLICATE_PACKAGE</td>
<td>已经存在同名程序</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_NO_SHARED_USER</td>
<td>请求的共享用户不存在</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_UPDATE_INCOMPATIBLE</td>
<td>以前安装过同名应用，但卸载时数据没有移除；或者已安装该应用，但签名不一致</td>
<td>先 <code>adb uninstall &lt;packagename&gt;</code> 再安装</td>
</tr>
<tr>
<td>INSTALL_FAILED_SHARED_USER_INCOMPATIBLE</td>
<td>请求的共享用户存在但签名不一致</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_MISSING_SHARED_LIBRARY</td>
<td>安装包使用了设备上不可用的共享库</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_REPLACE_COULDNT_DELETE</td>
<td>替换时无法删除</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_DEXOPT</td>
<td>dex 优化验证失败或空间不足</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_OLDER_SDK</td>
<td>设备系统版本低于应用要求</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_CONFLICTING_PROVIDER</td>
<td>设备里已经存在与应用里同名的 content provider</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_NEWER_SDK</td>
<td>设备系统版本高于应用要求</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_TEST_ONLY</td>
<td>应用是 test-only 的，但安装时没有指定 <code>-t</code> 参数</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_CPU_ABI_INCOMPATIBLE</td>
<td>包含不兼容设备 CPU 应用程序二进制接口的 native code</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_MISSING_FEATURE</td>
<td>应用使用了设备不可用的功能</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_CONTAINER_ERROR</td>
<td>1. sdcard 访问失败; 2. 应用签名与 ROM 签名一致，被当作内置应用。</td>
<td>1. 确认 sdcard 可用，或者安装到内置存储; 2. 打包时不与 ROM 使用相同签名。</td>
</tr>
<tr>
<td>INSTALL_FAILED_INVALID_INSTALL_LOCATION</td>
<td>1. 不能安装到指定位置; 2. 应用签名与 ROM 签名一致，被当作内置应用。</td>
<td>1. 切换安装位置，添加或删除 <code>-s</code> 参数; 2. 打包时不与 ROM 使用相同签名。</td>
</tr>
<tr>
<td>INSTALL_FAILED_MEDIA_UNAVAILABLE</td>
<td>安装位置不可用</td>
<td>一般为 sdcard，确认 sdcard 可用或安装到内置存储</td>
</tr>
<tr>
<td>INSTALL_FAILED_VERIFICATION_TIMEOUT</td>
<td>验证安装包超时</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_VERIFICATION_FAILURE</td>
<td>验证安装包失败</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_PACKAGE_CHANGED</td>
<td>应用与调用程序期望的不一致</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_UID_CHANGED</td>
<td>以前安装过该应用，与本次分配的 UID 不一致</td>
<td>清除以前安装过的残留文件</td>
</tr>
<tr>
<td>INSTALL_FAILED_VERSION_DOWNGRADE</td>
<td>已经安装了该应用更高版本</td>
<td>使用 <code>-d</code> 参数</td>
</tr>
<tr>
<td>INSTALL_FAILED_PERMISSION_MODEL_DOWNGRADE</td>
<td>已安装 target SDK 支持运行时权限的同名应用，要安装的版本不支持运行时权限</td>
<td></td>
</tr>
<tr>
<td>INSTALL_PARSE_FAILED_NOT_APK</td>
<td>指定路径不是文件，或不是以 <code>.apk</code> 结尾</td>
<td></td>
</tr>
<tr>
<td>INSTALL_PARSE_FAILED_BAD_MANIFEST</td>
<td>无法解析的 AndroidManifest.xml 文件</td>
<td></td>
</tr>
<tr>
<td>INSTALL_PARSE_FAILED_UNEXPECTED_EXCEPTION</td>
<td>解析器遇到异常</td>
<td></td>
</tr>
<tr>
<td>INSTALL_PARSE_FAILED_NO_CERTIFICATES</td>
<td>安装包没有签名</td>
<td></td>
</tr>
<tr>
<td>INSTALL_PARSE_FAILED_INCONSISTENT_CERTIFICATES</td>
<td>已安装该应用，且签名与 APK 文件不一致</td>
<td>先卸载设备上的该应用，再安装</td>
</tr>
<tr>
<td>INSTALL_PARSE_FAILED_CERTIFICATE_ENCODING</td>
<td>解析 APK 文件时遇到 <code>CertificateEncodingException</code></td>
<td></td>
</tr>
<tr>
<td>INSTALL_PARSE_FAILED_BAD_PACKAGE_NAME</td>
<td>manifest 文件里没有或者使用了无效的包名</td>
<td></td>
</tr>
<tr>
<td>INSTALL_PARSE_FAILED_BAD_SHARED_USER_ID</td>
<td>manifest 文件里指定了无效的共享用户 ID</td>
<td></td>
</tr>
<tr>
<td>INSTALL_PARSE_FAILED_MANIFEST_MALFORMED</td>
<td>解析 manifest 文件时遇到结构性错误</td>
<td></td>
</tr>
<tr>
<td>INSTALL_PARSE_FAILED_MANIFEST_EMPTY</td>
<td>在 manifest 文件里找不到找可操作标签（instrumentation 或 application）</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_INTERNAL_ERROR</td>
<td>因系统问题安装失败</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_USER_RESTRICTED</td>
<td>用户被限制安装应用</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_DUPLICATE_PERMISSION</td>
<td>应用尝试定义一个已经存在的权限名称</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_NO_MATCHING_ABIS</td>
<td>应用包含设备的应用程序二进制接口不支持的 native code</td>
<td></td>
</tr>
<tr>
<td>INSTALL_CANCELED_BY_USER</td>
<td>应用安装需要在设备上确认，但未操作设备或点了取消</td>
<td>在设备上同意安装</td>
</tr>
<tr>
<td>INSTALL_FAILED_ACWF_INCOMPATIBLE</td>
<td>应用程序与设备不兼容</td>
<td></td>
</tr>
<tr>
<td>does not contain AndroidManifest.xml</td>
<td>无效的 APK 文件</td>
<td></td>
</tr>
<tr>
<td>is not a valid zip file</td>
<td>无效的 APK 文件</td>
<td></td>
</tr>
<tr>
<td>Offline</td>
<td>设备未连接成功</td>
<td>先将设备与 adb 连接成功</td>
</tr>
<tr>
<td>unauthorized</td>
<td>设备未授权允许调试</td>
<td></td>
</tr>
<tr>
<td>error: device not found</td>
<td>没有连接成功的设备</td>
<td>先将设备与 adb 连接成功</td>
</tr>
<tr>
<td>protocol failure</td>
<td>设备已断开连接</td>
<td>先将设备与 adb 连接成功</td>
</tr>
<tr>
<td>Unknown option: -s</td>
<td>Android 2.2 以下不支持安装到 sdcard</td>
<td>不使用 <code>-s</code> 参数</td>
</tr>
<tr>
<td>No space left on device</td>
<td>空间不足</td>
<td>清理空间</td>
</tr>
<tr>
<td>Permission denied &hellip; sdcard &hellip;</td>
<td>sdcard 不可用</td>
<td></td>
</tr>
<tr>
<td>signatures do not match the previously installed version; ignoring!</td>
<td>已安装该应用且签名不一致</td>
<td>先卸载设备上的该应用，再安装</td>
</tr>
</tbody>
</table>
<p>参考：[<a href="https://github.com/aosp-mirror/platform_frameworks_base/blob/master/core/java/android/content/pm/PackageManager.java">PackageManager.java]</a></p>
<h3 id="adb-install-内部原理简介">adb install 内部原理简介</h3>
<p>adb install 实际是分三步完成：</p>
<ol>
<li>push apk 文件到 /data/local/tmp。</li>
<li>调用 pm install 安装。</li>
<li>删除 /data/local/tmp 下的对应 apk 文件。</li>
</ol>
<p>所以，必要的时候也可以根据这个步骤，手动分步执行安装过程。</p>
<h3 id="卸载应用">卸载应用</h3>
<p>命令：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>adb uninstall <span style="color:#f92672">[</span>-k<span style="color:#f92672">]</span> &lt;packagename&gt;
</span></span></code></pre></div><p><code>&lt;packagename&gt;</code> 表示应用的包名，-k 参数可选，表示卸载应用但保留数据和缓存目录。
命令示例：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>adb uninstall com.qihoo360.mobilesafe
</span></span></code></pre></div><p>表示卸载 360 手机卫士。</p>
<h3 id="清除应用数据与缓存">清除应用数据与缓存</h3>
<p>命令：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>adb shell pm clear &lt;packagename&gt;
</span></span></code></pre></div><p><code>&lt;packagename&gt;</code> 表示应用名包，这条命令的效果相当于在设置里的应用信息界面点击了「清除缓存」和「清除数据」。</p>
<p>命令示例：</p>
<pre tabindex="0"><code>adb shell pm clear com.qihoo360.mobilesafe
</code></pre><p>表示清除 360 手机卫士的数据和缓存。</p>
<h3 id="查看前台-activity">查看前台 Activity</h3>
<p>命令：</p>
<pre tabindex="0"><code>adb shell dumpsys activity activities | grep mFocusedActivity
</code></pre><p>输出示例：</p>
<pre tabindex="0"><code>mFocusedActivity: ActivityRecord{8079d7e u0 com.cyanogenmod.trebuchet/com.android.launcher3.Launcher t42}
</code></pre><p>其中的 <code>com.cyanogenmod.trebuchet/com.android.launcher3.Launcher</code> 就是当前处于前台的 Activity。</p>
<h3 id="查看正在运行的-services">查看正在运行的 Services</h3>
<p>命令：</p>
<pre tabindex="0"><code>adb shell dumpsys activity services [&lt;packagename&gt;]
</code></pre><p><code>&lt;packagename&gt;</code> 参数不是必须的，指定 <code>&lt;packagename&gt;</code> 表示查看与某个包名相关的 Services，不指定表示查看所有 Services。</p>
<p><code>&lt;packagename&gt;</code> 不一定要给出完整的包名，比如运行 adb shell dumpsys activity services org.mazhuang，那么包名 org.mazhuang.demo1、org.mazhuang.demo2 和 org.mazhuang123 等相关的 Services 都会列出来。</p>
<h3 id="查看应用详细信息">查看应用详细信息</h3>
<p>命令：</p>
<pre tabindex="0"><code>adb shell dumpsys package &lt;packagename&gt;
1
</code></pre><p>输出中包含很多信息，包括 Activity Resolver Table、Registered ContentProviders、包名、userId、安装后的文件资源代码等路径、版本信息、权限信息和授予状态、签名版本信息等。</p>
<p><code>&lt;packagename&gt;</code> 表示应用包名。</p>
<p>输出示例：</p>
<pre tabindex="0"><code>Activity Resolver Table:
  Non-Data Actions:
      android.intent.action.MAIN:
        5b4cba8 org.mazhuang.guanggoo/.SplashActivity filter 5ec9dcc
          Action: &#34;android.intent.action.MAIN&#34;
          Category: &#34;android.intent.category.LAUNCHER&#34;
          AutoVerify=false

Registered ContentProviders:
  org.mazhuang.guanggoo/com.tencent.bugly.beta.utils.BuglyFileProvider:
    Provider{7a3c394 org.mazhuang.guanggoo/com.tencent.bugly.beta.utils.BuglyFileProvider}

ContentProvider Authorities:
  [org.mazhuang.guanggoo.fileProvider]:
    Provider{7a3c394 org.mazhuang.guanggoo/com.tencent.bugly.beta.utils.BuglyFileProvider}
      applicationInfo=ApplicationInfo{7754242 org.mazhuang.guanggoo}

Key Set Manager:
  [org.mazhuang.guanggoo]
      Signing KeySets: 501

Packages:
  Package [org.mazhuang.guanggoo] (c1d7f):
    userId=10394
    pkg=Package{55f714c org.mazhuang.guanggoo}
    codePath=/data/app/org.mazhuang.guanggoo-2
    resourcePath=/data/app/org.mazhuang.guanggoo-2
    legacyNativeLibraryDir=/data/app/org.mazhuang.guanggoo-2/lib
    primaryCpuAbi=null
    secondaryCpuAbi=null
    versionCode=74 minSdk=15 targetSdk=25
    versionName=1.1.74
    splits=[base]
    apkSigningVersion=2
    applicationInfo=ApplicationInfo{7754242 org.mazhuang.guanggoo}
    flags=[ HAS_CODE ALLOW_CLEAR_USER_DATA ALLOW_BACKUP ]
    privateFlags=[ RESIZEABLE_ACTIVITIES ]
    dataDir=/data/user/0/org.mazhuang.guanggoo
    supportsScreens=[small, medium, large, xlarge, resizeable, anyDensity]
    timeStamp=2017-10-22 23:50:53
    firstInstallTime=2017-10-22 23:50:25
    lastUpdateTime=2017-10-22 23:50:55
    installerPackageName=com.miui.packageinstaller
    signatures=PackageSignatures{af09595 [53c7caa2]}
    installPermissionsFixed=true installStatus=1
    pkgFlags=[ HAS_CODE ALLOW_CLEAR_USER_DATA ALLOW_BACKUP ]
    requested permissions:
      android.permission.READ_PHONE_STATE
      android.permission.INTERNET
      android.permission.ACCESS_NETWORK_STATE
      android.permission.ACCESS_WIFI_STATE
      android.permission.READ_LOGS
      android.permission.WRITE_EXTERNAL_STORAGE
      android.permission.READ_EXTERNAL_STORAGE
    install permissions:
      android.permission.INTERNET: granted=true
      android.permission.ACCESS_NETWORK_STATE: granted=true
      android.permission.ACCESS_WIFI_STATE: granted=true
    User 0: ceDataInode=1155675 installed=true hidden=false suspended=false stopped=true notLaunched=false enabled=0
      gids=[3003]
      runtime permissions:
        android.permission.READ_EXTERNAL_STORAGE: granted=true
        android.permission.READ_PHONE_STATE: granted=true
        android.permission.WRITE_EXTERNAL_STORAGE: granted=true
    User 999: ceDataInode=0 installed=false hidden=false suspended=false stopped=true notLaunched=true enabled=0
      gids=[3003]
      runtime permissions:


Dexopt state:
  [org.mazhuang.guanggoo]
    Instruction Set: arm64
      path: /data/app/org.mazhuang.guanggoo-2/base.apk
      status: /data/app/org.mazhuang.guanggoo-2/oat/arm64/base.odex [compilation_filter=speed-profile, status=kOatUpToDa
      te]
123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475
</code></pre><h2 id="与应用交互">与应用交互</h2>
<p>主要是使用 <code>am &lt;command&gt;</code> 命令，常用的 <code>&lt;command&gt;</code> 如下：</p>
<table>
<thead>
<tr>
<th>command</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>start [options] &lt;INTENT&gt;</code></td>
<td>启动 <code>&lt;INTENT&gt;</code> 指定的 Activity</td>
</tr>
<tr>
<td><code>startservice [options] &lt;INTENT&gt;</code></td>
<td>启动 <code>&lt;INTENT&gt;</code> 指定的 Service</td>
</tr>
<tr>
<td><code>broadcast [options] &lt;INTENT&gt;</code></td>
<td>发送 <code>&lt;INTENT&gt;</code> 指定的广播</td>
</tr>
<tr>
<td><code>force-stop &lt;packagename&gt;</code></td>
<td>停止 <code>&lt;packagename&gt;</code> 相关的进程</td>
</tr>
</tbody>
</table>
<p><code>&lt;INTENT&gt;</code> 参数很灵活，和写 Android 程序时代码里的 Intent 相对应。</p>
<p>用于决定 intent 对象的选项如下：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>-a &lt;ACTION&gt;</code></td>
<td>指定 action，比如 <code>android.intent.action.VIEW</code></td>
</tr>
<tr>
<td><code>-c &lt;CATEGORY&gt;</code></td>
<td>指定 category，比如 <code>android.intent.category.APP_CONTACTS</code></td>
</tr>
<tr>
<td><code>-n &lt;COMPONENT&gt;</code></td>
<td>指定完整 component 名，用于明确指定启动哪个 Activity，如 <code>com.example.app/.ExampleActivity</code></td>
</tr>
</tbody>
</table>
<p><code>&lt;INTENT&gt;</code> 里还能带数据，就像写代码时的 Bundle 一样：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>--esn &lt;EXTRA_KEY&gt;</code></td>
<td>null 值（只有 key 名）</td>
</tr>
<tr>
<td>`-e</td>
<td>&ndash;es &lt;EXTRA_KEY&gt; &lt;EXTRA_STRING_VALUE&gt;`</td>
</tr>
<tr>
<td><code>--ez &lt;EXTRA_KEY&gt; &lt;EXTRA_BOOLEAN_VALUE&gt;</code></td>
<td>boolean 值</td>
</tr>
<tr>
<td><code>--ei &lt;EXTRA_KEY&gt; &lt;EXTRA_INT_VALUE&gt;</code></td>
<td>integer 值</td>
</tr>
<tr>
<td><code>--el &lt;EXTRA_KEY&gt; &lt;EXTRA_LONG_VALUE&gt;</code></td>
<td>long 值</td>
</tr>
<tr>
<td><code>--ef &lt;EXTRA_KEY&gt; &lt;EXTRA_FLOAT_VALUE&gt;</code></td>
<td>float 值</td>
</tr>
<tr>
<td><code>--eu &lt;EXTRA_KEY&gt; &lt;EXTRA_URI_VALUE&gt;</code></td>
<td>URI</td>
</tr>
<tr>
<td><code>--ecn &lt;EXTRA_KEY&gt; &lt;EXTRA_COMPONENT_NAME_VALUE&gt;</code></td>
<td>component name</td>
</tr>
<tr>
<td><code>--eia &lt;EXTRA_KEY&gt; &lt;EXTRA_INT_VALUE&gt;[,&lt;EXTRA_INT_VALUE...]</code></td>
<td>integer 数组</td>
</tr>
<tr>
<td><code>--ela &lt;EXTRA_KEY&gt; &lt;EXTRA_LONG_VALUE&gt;[,&lt;EXTRA_LONG_VALUE...]</code></td>
<td>long 数组</td>
</tr>
</tbody>
</table>
<h3 id="调起-activity">调起 Activity</h3>
<p>命令格式：</p>
<pre tabindex="0"><code>adb shell am start [options] &lt;INTENT&gt;
1
</code></pre><p>例如：</p>
<pre tabindex="0"><code>adb shell am start -n com.tencent.mm/.ui.LauncherUI
1
</code></pre><p>表示调起微信主界面。</p>
<pre tabindex="0"><code>adb shell am start -n org.mazhuang.boottimemeasure/.MainActivity --es &#34;toast&#34; &#34;hello, world&#34;
1
</code></pre><p>表示调起 org.mazhuang.boottimemeasure/.MainActivity 并传给它 string 数据键值对 toast - hello, world。</p>
<h3 id="调起-service">调起 Service</h3>
<p>命令格式：</p>
<pre tabindex="0"><code>adb shell am startservice [options] &lt;INTENT&gt;
1
</code></pre><p>例如：</p>
<pre tabindex="0"><code>adb shell am startservice -n com.tencent.mm/.plugin.accountsync.model.AccountAuthenticatorService
1
</code></pre><p>表示调起微信的某 Service。</p>
<h3 id="发送广播">发送广播</h3>
<p>命令格式：</p>
<pre tabindex="0"><code>adb shell am broadcast [options] &lt;INTENT&gt;
1
</code></pre><p>可以向所有组件广播，也可以只向指定组件广播。</p>
<p>例如，向所有组件广播 BOOT_COMPLETED：</p>
<pre tabindex="0"><code>adb shell am broadcast -a android.intent.action.BOOT_COMPLETED
1
</code></pre><p>又例如，只向 org.mazhuang.boottimemeasure/.BootCompletedReceiver 广播 BOOT_COMPLETED：</p>
<pre tabindex="0"><code>adb shell am broadcast -a android.intent.action.BOOT_COMPLETED -n org.mazhuang.boottimemeasure/.BootCompletedReceiver
1
</code></pre><p>这类用法在测试的时候很实用，比如某个广播的场景很难制造，可以考虑通过这种方式来发送广播。
既能发送系统预定义的广播，也能发送自定义广播。如下是部分系统预定义广播及正常触发时机：</p>
<table>
<thead>
<tr>
<th>action</th>
<th>触发时机</th>
</tr>
</thead>
<tbody>
<tr>
<td>android.net.conn.CONNECTIVITY_CHANGE</td>
<td>网络连接发生变化</td>
</tr>
<tr>
<td>android.intent.action.SCREEN_ON</td>
<td>屏幕点亮</td>
</tr>
<tr>
<td>android.intent.action.SCREEN_OFF</td>
<td>屏幕熄灭</td>
</tr>
<tr>
<td>android.intent.action.BATTERY_LOW</td>
<td>电量低，会弹出电量低提示框</td>
</tr>
<tr>
<td>android.intent.action.BATTERY_OKAY</td>
<td>电量恢复了</td>
</tr>
<tr>
<td>android.intent.action.BOOT_COMPLETED</td>
<td>设备启动完毕</td>
</tr>
<tr>
<td>android.intent.action.DEVICE_STORAGE_LOW</td>
<td>存储空间过低</td>
</tr>
<tr>
<td>android.intent.action.DEVICE_STORAGE_OK</td>
<td>存储空间恢复</td>
</tr>
<tr>
<td>android.intent.action.PACKAGE_ADDED</td>
<td>安装了新的应用</td>
</tr>
<tr>
<td>android.net.wifi.STATE_CHANGE</td>
<td>WiFi 连接状态发生变化</td>
</tr>
<tr>
<td>android.net.wifi.WIFI_STATE_CHANGED</td>
<td>WiFi 状态变为启用/关闭/正在启动/正在关闭/未知</td>
</tr>
<tr>
<td>android.intent.action.BATTERY_CHANGED</td>
<td>电池电量发生变化</td>
</tr>
<tr>
<td>android.intent.action.INPUT_METHOD_CHANGED</td>
<td>系统输入法发生变化</td>
</tr>
<tr>
<td>android.intent.action.ACTION_POWER_CONNECTED</td>
<td>外部电源连接</td>
</tr>
<tr>
<td>android.intent.action.ACTION_POWER_DISCONNECTED</td>
<td>外部电源断开连接</td>
</tr>
<tr>
<td>android.intent.action.DREAMING_STARTED</td>
<td>系统开始休眠</td>
</tr>
<tr>
<td>android.intent.action.DREAMING_STOPPED</td>
<td>系统停止休眠</td>
</tr>
<tr>
<td>android.intent.action.WALLPAPER_CHANGED</td>
<td>壁纸发生变化</td>
</tr>
<tr>
<td>android.intent.action.HEADSET_PLUG</td>
<td>插入耳机</td>
</tr>
<tr>
<td>android.intent.action.MEDIA_UNMOUNTED</td>
<td>卸载外部介质</td>
</tr>
<tr>
<td>android.intent.action.MEDIA_MOUNTED</td>
<td>挂载外部介质</td>
</tr>
<tr>
<td>android.os.action.POWER_SAVE_MODE_CHANGED</td>
<td>省电模式开启</td>
</tr>
</tbody>
</table>
<p><em>（以上广播均可使用 adb 触发）</em></p>
<h3 id="强制停止应用">强制停止应用</h3>
<p>命令：</p>
<pre tabindex="0"><code>adb shell am force-stop &lt;packagename&gt;
1
</code></pre><p>命令示例：</p>
<pre tabindex="0"><code>adb shell am force-stop com.qihoo360.mobilesafe
1
</code></pre><p>表示停止 360 安全卫士的一切进程与服务。</p>
<h2 id="文件管理">文件管理</h2>
<h3 id="复制设备里的文件到电脑">复制设备里的文件到电脑</h3>
<p>命令：</p>
<pre tabindex="0"><code>adb pull &lt;设备里的文件路径&gt; [电脑上的目录]
1
</code></pre><p>其中 电脑上的目录 参数可以省略，默认复制到当前目录。</p>
<p>例：</p>
<pre tabindex="0"><code>adb pull /sdcard/sr.mp4 ~/tmp/
1
</code></pre><p>*小技巧：*设备上的文件路径可能需要 root 权限才能访问，如果你的设备已经 root 过，可以先使用 adb shell 和 su 命令在 adb shell 里获取 root 权限后，先 cp /path/on/device /sdcard/filename 将文件复制到 sdcard，然后 adb pull /sdcard/filename /path/on/pc。</p>
<h3 id="复制电脑里的文件到设备">复制电脑里的文件到设备</h3>
<p>命令：</p>
<pre tabindex="0"><code>adb push &lt;电脑上的文件路径&gt; &lt;设备里的目录&gt;
1
</code></pre><p>例：</p>
<pre tabindex="0"><code>adb push ~/sr.mp4 /sdcard/
</code></pre><p>*小技巧：*设备上的文件路径普通权限可能无法直接写入，如果你的设备已经 root 过，可以先 adb push /path/on/pc /sdcard/filename，然后 adb shell 和 su 在 adb shell 里获取 root 权限后，cp /sdcard/filename /path/on/device。</p>
<h2 id="模拟按键输入">模拟按键/输入</h2>
<p>在 adb shell 里有个很实用的命令叫 input，通过它可以做一些有趣的事情。
input 命令的完整 help 信息如下：</p>
<pre tabindex="0"><code>Usage: input [&lt;source&gt;] &lt;command&gt; [&lt;arg&gt;...]

The sources are:
      mouse
      keyboard
      joystick
      touchnavigation
      touchpad
      trackball
      stylus
      dpad
      gesture
      touchscreen
      gamepad

The commands and default sources are:
      text &lt;string&gt; (Default: touchscreen)
      keyevent [--longpress] &lt;key code number or name&gt; ... (Default: keyboard)
      tap &lt;x&gt; &lt;y&gt; (Default: touchscreen)
      swipe &lt;x1&gt; &lt;y1&gt; &lt;x2&gt; &lt;y2&gt; [duration(ms)] (Default: touchscreen)
      press (Default: trackball)
      roll &lt;dx&gt; &lt;dy&gt; (Default: trackball)
12345678910111213141516171819202122
</code></pre><p>比如模拟点击：//在屏幕上点击坐标点x=50 y=250的位置。</p>
<blockquote>
<p>adb shell input tap 50 250</p>
</blockquote>
<p>比如使用 adb shell input keyevent 命令，不同的 keycode 能实现不同的功能，完整的 keycode 列表详见 KeyEvent，摘引部分我觉得有意思的如下：</p>
<table>
<thead>
<tr>
<th>keycode</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>3</td>
<td>HOME 键</td>
</tr>
<tr>
<td>4</td>
<td>返回键</td>
</tr>
<tr>
<td>5</td>
<td>打开拨号应用</td>
</tr>
<tr>
<td>6</td>
<td>挂断电话</td>
</tr>
<tr>
<td>24</td>
<td>增加音量</td>
</tr>
<tr>
<td>25</td>
<td>降低音量</td>
</tr>
<tr>
<td>26</td>
<td>电源键</td>
</tr>
<tr>
<td>27</td>
<td>拍照（需要在相机应用里）</td>
</tr>
<tr>
<td>64</td>
<td>打开浏览器</td>
</tr>
<tr>
<td>82</td>
<td>菜单键</td>
</tr>
<tr>
<td>85</td>
<td>播放/暂停</td>
</tr>
<tr>
<td>86</td>
<td>停止播放</td>
</tr>
<tr>
<td>87</td>
<td>播放下一首</td>
</tr>
<tr>
<td>88</td>
<td>播放上一首</td>
</tr>
<tr>
<td>122</td>
<td>移动光标到行首或列表顶部</td>
</tr>
<tr>
<td>123</td>
<td>移动光标到行末或列表底部</td>
</tr>
<tr>
<td>126</td>
<td>恢复播放</td>
</tr>
<tr>
<td>127</td>
<td>暂停播放</td>
</tr>
<tr>
<td>164</td>
<td>静音</td>
</tr>
<tr>
<td>176</td>
<td>打开系统设置</td>
</tr>
<tr>
<td>187</td>
<td>切换应用</td>
</tr>
<tr>
<td>207</td>
<td>打开联系人</td>
</tr>
<tr>
<td>208</td>
<td>打开日历</td>
</tr>
<tr>
<td>209</td>
<td>打开音乐</td>
</tr>
<tr>
<td>210</td>
<td>打开计算器</td>
</tr>
<tr>
<td>220</td>
<td>降低屏幕亮度</td>
</tr>
<tr>
<td>221</td>
<td>提高屏幕亮度</td>
</tr>
<tr>
<td>223</td>
<td>系统休眠</td>
</tr>
<tr>
<td>224</td>
<td>点亮屏幕</td>
</tr>
<tr>
<td>231</td>
<td>打开语音助手</td>
</tr>
<tr>
<td>276</td>
<td>如果没有 wakelock 则让系统休眠</td>
</tr>
</tbody>
</table>
<p>下面是 input 命令的一些用法举例。</p>
<h3 id="电源键">电源键</h3>
<pre tabindex="0"><code>db shell input keyevent 26
1
</code></pre><p>执行效果相当于按电源键。</p>
<h3 id="菜单键">菜单键</h3>
<p>命令：</p>
<pre tabindex="0"><code>adb shell input keyevent 82
1
</code></pre><h3 id="home-键">HOME 键</h3>
<p>命令：</p>
<pre tabindex="0"><code>adb shell input keyevent 3
1
</code></pre><h3 id="返回键">返回键</h3>
<p>命令：</p>
<pre tabindex="0"><code>adb shell input keyevent 4
1
</code></pre><h3 id="音量控制">音量控制</h3>
<p><strong>增加音量：</strong></p>
<pre tabindex="0"><code>adb shell input keyevent 24
1
</code></pre><p><strong>降低音量：</strong></p>
<pre tabindex="0"><code>adb shell input keyevent 25
1
</code></pre><p><strong>静音：</strong></p>
<pre tabindex="0"><code>adb shell input keyevent 164
1
</code></pre><h3 id="媒体控制">媒体控制</h3>
<p><strong>播放/暂停：</strong></p>
<pre tabindex="0"><code>adb shell input keyevent 85
1
</code></pre><p><strong>停止播放：</strong></p>
<pre tabindex="0"><code>adb shell input keyevent 86
1
</code></pre><p><strong>播放下一首：</strong></p>
<pre tabindex="0"><code>adb shell input keyevent 87
1
</code></pre><p><strong>播放上一首：</strong></p>
<pre tabindex="0"><code>adb shell input keyevent 88
1
</code></pre><p><strong>恢复播放：</strong></p>
<pre tabindex="0"><code>adb shell input keyevent 126
1
</code></pre><p><strong>暂停播放：</strong></p>
<pre tabindex="0"><code>adb shell input keyevent 127
1
</code></pre><h3 id="点亮熄灭屏幕">点亮/熄灭屏幕</h3>
<p>可以通过上文讲述过的模拟电源键来切换点亮和熄灭屏幕，但如果明确地想要点亮或者熄灭屏幕，那可以使用如下方法。</p>
<p><strong>点亮屏幕：</strong></p>
<pre tabindex="0"><code>adb shell input keyevent 224
1
</code></pre><p><strong>熄灭屏幕：</strong></p>
<pre tabindex="0"><code>adb shell input keyevent 223
1
</code></pre><h3 id="滑动解锁">滑动解锁</h3>
<p>如果锁屏没有密码，是通过滑动手势解锁，那么可以通过 input swipe 来解锁。</p>
<p>命令（参数以机型 Nexus 5，向上滑动手势解锁举例）：</p>
<pre tabindex="0"><code>adb shell input swipe 300 1000 300 500
1
</code></pre><p>参数 300 1000 300 500 分别表示起始点x坐标 起始点y坐标 结束点x坐标 结束点y坐标。</p>
<h3 id="输入文本">输入文本</h3>
<p>在焦点处于某文本框时，可以通过 input 命令来输入文本。</p>
<p>命令：</p>
<pre tabindex="0"><code>adb shell input text hello
1
</code></pre><p>现在 hello 出现在文本框了。</p>
<h2 id="查看日志">查看日志</h2>
<p>Android 系统的日志分为两部分，底层的 Linux 内核日志输出到 /proc/kmsg，Android 的日志输出到 /dev/log。</p>
<h3 id="android-日志">Android 日志</h3>
<p>命令格式：</p>
<pre tabindex="0"><code>[adb] logcat [&lt;option&gt;] ... [&lt;filter-spec&gt;] ...
1
</code></pre><p>常用用法列举如下：</p>
<p>按级别过滤日志</p>
<p>Android 的日志分为如下几个优先级（priority）：</p>
<ul>
<li>V —— Verbose（最低，输出得最多）</li>
<li>D —— Debug I —— Info</li>
<li>W —— Warning</li>
<li>E —— Error</li>
<li>F—— Fatal</li>
<li>S —— Silent（最高，啥也不输出）</li>
</ul>
<p>按某级别过滤日志则会将该级别及以上的日志输出。</p>
<p>比如，命令：</p>
<pre tabindex="0"><code>adb logcat *:W
1
</code></pre><p>会将 Warning、Error、Fatal 和 Silent 日志输出。</p>
<p>（注： 在 macOS 下需要给 <em>:W 这样以 * 作为 tag 的参数加双引号，如 adb logcat &ldquo;</em>:W&rdquo;，不然会报错 no matches found: *:W。）</p>
<p><strong>按 tag 和级别过滤日志</strong></p>
<p><code>&lt;filter-spec&gt;</code> 可以由多个 <code>&lt;tag&gt;[:priority]</code> 组成。</p>
<p>比如，命令：</p>
<pre tabindex="0"><code>adb logcat ActivityManager:I MyApp:D *:S
1
</code></pre><p>表示输出 tag ActivityManager 的 Info 以上级别日志，输出 tag MyApp 的 Debug 以上级别日志，及其它 tag 的 Silent 级别日志（即屏蔽其它 tag 日志）。</p>
<p><strong>日志格式</strong></p>
<p>可以用 <code>adb logcat -v &lt;format&gt;</code> 选项指定日志输出格式。</p>
<p>日志支持按以下几种 <code>&lt;format&gt;</code>：</p>
<ul>
<li>
<p>brief</p>
<p>默认格式。格式为：</p>
<pre tabindex="0"><code> &lt;priority&gt;/&lt;tag&gt;(&lt;pid&gt;): &lt;message&gt;
1
</code></pre></li>
</ul>
<p>示例：</p>
<pre tabindex="0"><code>	D/HeadsetStateMachine( 1785): Disconnected process message: 10, size: 0
1
</code></pre><ul>
<li>
<p>process</p>
<p>格式为：</p>
<pre tabindex="0"><code> &lt;priority&gt;(&lt;pid&gt;) &lt;message&gt;
1
</code></pre></li>
</ul>
<p>示例：</p>
<pre tabindex="0"><code>	D( 1785) Disconnected process message: 10, size: 0  (HeadsetStateMachine)
1
</code></pre><ul>
<li>
<p>tag</p>
<p>格式为：</p>
<pre tabindex="0"><code> &lt;priority&gt;/&lt;tag&gt;: &lt;message&gt;
1
</code></pre></li>
</ul>
<p>示例：</p>
<pre tabindex="0"><code>	D/HeadsetStateMachine: Disconnected process message: 10, size: 0 
1
</code></pre><ul>
<li>
<p>raw</p>
<p>格式为：</p>
<pre tabindex="0"><code> &lt;message&gt;
1
</code></pre><p>示例：</p>
<pre tabindex="0"><code> Disconnected process message: 10, size: 0 
1
</code></pre></li>
<li>
<p>time</p>
<p>格式为：</p>
<pre tabindex="0"><code> &lt;datetime&gt; &lt;priority&gt;/&lt;tag&gt;(&lt;pid&gt;): &lt;message&gt;
1
</code></pre><p>示例：</p>
<pre tabindex="0"><code> 08-28 22:39:39.974 D/HeadsetStateMachine( 1785): Disconnected process message: 10, size: 0
1
</code></pre></li>
<li>
<p>threadtime</p>
<p>格式为：</p>
<pre tabindex="0"><code> &lt;datetime&gt; &lt;pid&gt; &lt;tid&gt; &lt;priority&gt; &lt;tag&gt;: &lt;message&gt;
1
</code></pre><p>示例：</p>
<pre tabindex="0"><code> 08-28 22:39:39.974  1785  1832 D HeadsetStateMachine: Disconnected process message: 10, size: 0
1
</code></pre></li>
<li>
<p>long</p>
<p>格式为：</p>
<pre tabindex="0"><code> [ &lt;datetime&gt; &lt;pid&gt;:&lt;tid&gt; &lt;priority&gt;/&lt;tag&gt; ]	&lt;message&gt;
1
</code></pre></li>
</ul>
<p>示例：</p>
<pre tabindex="0"><code>	[ 08-28 22:39:39.974  1785: 1832 D/HeadsetStateMachine ] Disconnected process message: 10, size: 0
1
</code></pre><p>指定格式可与上面的过滤同时使用。比如：</p>
<pre tabindex="0"><code>adb logcat -v long ActivityManager:I *:S
1
</code></pre><p><strong>清空日志</strong></p>
<pre tabindex="0"><code>adb logcat -c
1
</code></pre><h3 id="内核日志">内核日志</h3>
<p>命令：</p>
<pre tabindex="0"><code>adb shell dmesg
1
</code></pre><p>输出示例：</p>
<pre tabindex="0"><code>&lt;6&gt;[14201.684016] PM: noirq resume of devices complete after 0.982 msecs
&lt;6&gt;[14201.685525] PM: early resume of devices complete after 0.838 msecs
&lt;6&gt;[14201.753642] PM: resume of devices complete after 68.106 msecs
&lt;4&gt;[14201.755954] Restarting tasks ... done.
&lt;6&gt;[14201.771229] PM: suspend exit 2016-08-28 13:31:32.679217193 UTC
&lt;6&gt;[14201.872373] PM: suspend entry 2016-08-28 13:31:32.780363596 UTC
&lt;6&gt;[14201.872498] PM: Syncing filesystems ... done.
1234567
</code></pre><p>中括号里的 [14201.684016] 代表内核开始启动后的时间，单位为秒。</p>
<p>通过内核日志我们可以做一些事情，比如衡量内核启动时间，在系统启动完毕后的内核日志里找到 Freeing init memory 那一行前面的时间就是。</p>
<h2 id="查看设备信息">查看设备信息</h2>
<h3 id="型号">型号</h3>
<p>命令：</p>
<pre tabindex="0"><code>adb shell getprop ro.product.model
1
</code></pre><p>输出示例：</p>
<p>Nexus 5</p>
<h3 id="电池状况">电池状况</h3>
<p>命令：</p>
<pre tabindex="0"><code>adb shell dumpsys battery
1
</code></pre><p>输入示例：</p>
<pre tabindex="0"><code>  Current Battery Service state:
  AC powered: false
  USB powered: true
  Wireless powered: false
  status: 2
  health: 2
  present: true
  level: 44
  scale: 100
  voltage: 3872
  temperature: 280
  technology: Li-poly
123456789101112
</code></pre><p>其中 scale 代表最大电量，level 代表当前电量。上面的输出表示还剩下 44% 的电量。</p>
<h3 id="屏幕分辨率">屏幕分辨率</h3>
<p>命令：</p>
<pre tabindex="0"><code>adb shell wm size
1
</code></pre><p>输出示例：</p>
<pre tabindex="0"><code>Physical size: 1080x1920
1
</code></pre><p>该设备屏幕分辨率为 1080px * 1920px。</p>
<p>如果使用命令修改过，那输出可能是：</p>
<pre tabindex="0"><code>Physical size: 1080x1920
Override size: 480x1024
12
</code></pre><p>表明设备的屏幕分辨率原本是 1080px * 1920px，当前被修改为 480px * 1024px。</p>
<h3 id="屏幕密度">屏幕密度</h3>
<p>命令：</p>
<p>adb shell wm density
输出示例：</p>
<p>Physical density: 420
该设备屏幕密度为 420dpi。</p>
<p>如果使用命令修改过，那输出可能是：</p>
<p>Physical density: 480
Override density: 160
表明设备的屏幕密度原来是 480dpi，当前被修改为 160dpi。</p>
<h3 id="显示屏参数">显示屏参数</h3>
<p>命令：</p>
<pre tabindex="0"><code>adb shell dumpsys window displays
1
</code></pre><p>输出示例：</p>
<pre tabindex="0"><code>WINDOW MANAGER DISPLAY CONTENTS (dumpsys window displays)
  Display: mDisplayId=0
    init=1080x1920 420dpi cur=1080x1920 app=1080x1794 rng=1080x1017-1810x1731
    deferred=false layoutNeeded=false
1234
</code></pre><p>其中 mDisplayId 为 显示屏编号，init 是初始分辨率和屏幕密度，app 的高度比 init 里的要小，表示屏幕底部有虚拟按键，高度为 1920 - 1794 = 126px 合 42dp。</p>
<h3 id="android_id">android_id</h3>
<p>命令：</p>
<pre tabindex="0"><code>adb shell settings get secure android_id
1
</code></pre><p>输出示例：</p>
<pre tabindex="0"><code>51b6be48bac8c569
1
</code></pre><h3 id="imei">IMEI</h3>
<p>在 Android 4.4 及以下版本可通过如下命令获取 IMEI：</p>
<pre tabindex="0"><code>adb shell dumpsys iphonesubinfo
1
</code></pre><p>输出示例：</p>
<pre tabindex="0"><code>Phone Subscriber Info:
  Phone Type = GSM
  Device ID = 860955027785041
其中的 Device ID 就是 IMEI。
1234
</code></pre><p>而在 Android 5.0 及以上版本里这个命令输出为空，得通过其它方式获取了（需要 root 权限）：</p>
<pre tabindex="0"><code>adb shell
su
service call iphonesubinfo 1
123
</code></pre><p>输出示例：</p>
<pre tabindex="0"><code>Result: Parcel(
  0x00000000: 00000000 0000000f 00360038 00390030 &#39;........8.6.0.9.&#39;
  0x00000010: 00350035 00320030 00370037 00350038 &#39;5.5.0.2.7.7.8.5.&#39;
  0x00000020: 00340030 00000031                   &#39;0.4.1...        &#39;)
1234
</code></pre><p>把里面的有效内容提取出来就是 IMEI 了，比如这里的是 860955027785041。</p>
<p>参考：adb shell dumpsys iphonesubinfo not working since Android 5.0 Lollipop</p>
<h3 id="android-系统版本">Android 系统版本</h3>
<p>命令：</p>
<pre tabindex="0"><code>adb shell getprop ro.build.version.release
1
</code></pre><p>输出示例：</p>
<p>5.0.2</p>
<h3 id="ip-地址">IP 地址</h3>
<p>每次想知道设备的 IP 地址的时候都得「设置」-「关于手机」-「状态信息」-「IP地址」很烦对不对？通过 adb 可以方便地查看。</p>
<p>命令：</p>
<pre tabindex="0"><code>adb shell ifconfig &#34;| grep Mask&#34;
1
</code></pre><p>输出示例：</p>
<pre tabindex="0"><code>inet addr:10.130.245.230  Mask:255.255.255.252
inet addr:127.0.0.1  Mask:255.0.0.0
12
</code></pre><p>那么 10.130.245.230 就是设备 IP 地址。</p>
<p>在有的设备上这个命令没有输出，如果设备连着 WiFi，可以使用如下命令来查看局域网 adb shell ifconfig wlan0例：</p>
<pre tabindex="0"><code>wlan0: ip 10.129.160.99 mask 255.255.240.0 flags [up broadcast running multicast]
1
</code></pre><p>或</p>
<pre tabindex="0"><code>wlan0     Link encap:UNSPEC
          inet addr:10.129.168.57  Bcast:10.129.175.255  Mask:255.255.240.0
          inet6 addr: fe80::66cc:2eff:fe68:b6b6/64 Scope: Link
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:496520 errors:0 dropped:0 overruns:0 frame:0
          TX packets:68215 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:3000
          RX bytes:116266821 TX bytes:8311736
12345678
</code></pre><p>如果以上命令仍然不能得到期望的信息，那可以试试以下命令（部分系统版本里可用）：</p>
<pre tabindex="0"><code>adb shell netcfg
1
</code></pre><p>输出示例：</p>
<pre tabindex="0"><code>wlan0    UP                               10.129.160.99/20  0x00001043 f8:a9:d0:17:42:4d
lo       UP                                   127.0.0.1/8   0x00000049 00:00:00:00:00:00
p2p0     UP                                     0.0.0.0/0   0x00001003 fa:a9:d0:17:42:4d
sit0     DOWN                                   0.0.0.0/0   0x00000080 00:00:00:00:00:00
rmnet0   DOWN                                   0.0.0.0/0   0x00000000 00:00:00:00:00:00
rmnet1   DOWN                                   0.0.0.0/0   0x00000000 00:00:00:00:00:00
rmnet3   DOWN                                   0.0.0.0/0   0x00000000 00:00:00:00:00:00
rmnet2   DOWN                                   0.0.0.0/0   0x00000000 00:00:00:00:00:00
rmnet4   DOWN                                   0.0.0.0/0   0x00000000 00:00:00:00:00:00
rmnet6   DOWN                                   0.0.0.0/0   0x00000000 00:00:00:00:00:00
rmnet5   DOWN                                   0.0.0.0/0   0x00000000 00:00:00:00:00:00
rmnet7   DOWN                                   0.0.0.0/0   0x00000000 00:00:00:00:00:00
rev_rmnet3 DOWN                                   0.0.0.0/0   0x00001002 4e:b7:e4:2e:17:58
rev_rmnet2 DOWN                                   0.0.0.0/0   0x00001002 4e:f0:c8:bf:7a:cf
rev_rmnet4 DOWN                                   0.0.0.0/0   0x00001002 a6:c0:3b:6b:c4:1f
rev_rmnet6 DOWN                                   0.0.0.0/0   0x00001002 66:bb:5d:64:2e:e9
rev_rmnet5 DOWN                                   0.0.0.0/0   0x00001002 0e:1b:eb:b9:23:a0
rev_rmnet7 DOWN                                   0.0.0.0/0   0x00001002 7a:d9:f6:81:40:5a
rev_rmnet8 DOWN                                   0.0.0.0/0   0x00001002 4e:e2:a9:bb:d0:1b
rev_rmnet0 DOWN                                   0.0.0.0/0   0x00001002 fe:65:d0:ca:82:a9
rev_rmnet1 DOWN                                   0.0.0.0/0   0x00001002 da:d8:e8:4f:2e:fe
123456789101112131415161718192021
</code></pre><p>可以看到网络连接名称、启用状态、IP 地址和 Mac 地址等信息。</p>
<h3 id="mac-地址">Mac 地址</h3>
<p>命令：</p>
<pre tabindex="0"><code>adb shell cat /sys/class/net/wlan0/address
1
</code></pre><p>输出示例：</p>
<pre tabindex="0"><code>f8:a9:d0:17:42:4d
1
</code></pre><p>这查看的是局域网 Mac 地址，移动网络或其它连接的信息可以通过前面的小节「IP 地址」里提到的 adb shell netcfg 命令来查看。</p>
<h3 id="cpu-信息">CPU 信息</h3>
<p>命令：</p>
<pre tabindex="0"><code>adb shell cat /proc/cpuinfo
1
</code></pre><p>输出示例：</p>
<pre tabindex="0"><code>Processor       : ARMv7 Processor rev 0 (v7l)
processor       : 0
BogoMIPS        : 38.40

processor       : 1
BogoMIPS        : 38.40

processor       : 2
BogoMIPS        : 38.40

processor       : 3
BogoMIPS        : 38.40

Features        : swp half thumb fastmult vfp edsp neon vfpv3 tls vfpv4 idiva idivt
CPU implementer : 0x51
CPU architecture: 7
CPU variant     : 0x2
CPU part        : 0x06f
CPU revision    : 0

Hardware        : Qualcomm MSM 8974 HAMMERHEAD (Flattened Device Tree)
Revision        : 000b
Serial          : 0000000000000000
1234567891011121314151617181920212223
</code></pre><p>这是 Nexus 5 的 CPU 信息，我们从输出里可以看到使用的硬件是 Qualcomm MSM 8974，processor 的编号是 0 到 3，所以它是四核的，采用的架构是 ARMv7 Processor rev 0 (v71)。</p>
<h3 id="内存信息">内存信息</h3>
<p>命令：</p>
<pre tabindex="0"><code>adb shell cat /proc/meminfo
1
</code></pre><p>输出示例：</p>
<pre tabindex="0"><code>MemTotal:        1027424 kB
MemFree:          486564 kB
Buffers:           15224 kB
Cached:            72464 kB
SwapCached:        24152 kB
Active:           110572 kB
Inactive:         259060 kB
Active(anon):      79176 kB
Inactive(anon):   207736 kB
Active(file):      31396 kB
Inactive(file):    51324 kB
Unevictable:        3948 kB
Mlocked:               0 kB
HighTotal:        409600 kB
HighFree:         132612 kB
LowTotal:         617824 kB
LowFree:          353952 kB
SwapTotal:        262140 kB
SwapFree:         207572 kB
Dirty:                 0 kB
Writeback:             0 kB
AnonPages:        265324 kB
Mapped:            47072 kB
Shmem:              1020 kB
Slab:              57372 kB
SReclaimable:       7692 kB
SUnreclaim:        49680 kB
KernelStack:        4512 kB
PageTables:         5912 kB
NFS_Unstable:          0 kB
Bounce:                0 kB
WritebackTmp:          0 kB
CommitLimit:      775852 kB
Committed_AS:   13520632 kB
VmallocTotal:     385024 kB
VmallocUsed:       61004 kB
VmallocChunk:     209668 kB
12345678910111213141516171819202122232425262728293031323334353637
</code></pre><p>其中，MemTotal 就是设备的总内存，MemFree 是当前空闲内存。</p>
<h3 id="更多硬件与系统属性">更多硬件与系统属性</h3>
<p>设备的更多硬件与系统属性可以通过如下命令查看：</p>
<pre tabindex="0"><code>adb shell cat /system/build.prop
1
</code></pre><p>这会输出很多信息，包括前面几个小节提到的「型号」和「Android 系统版本」等。</p>
<p>输出里还包括一些其它有用的信息，它们也可通过 adb shell getprop &lt;属性名&gt; 命令单独查看，列举一部分属性如下：</p>
<table>
<thead>
<tr>
<th>属性名</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>ro.build.version.sdk</td>
<td>SDK 版本</td>
</tr>
<tr>
<td>ro.build.version.release</td>
<td>Android 系统版本</td>
</tr>
<tr>
<td>ro.build.version.security_patch</td>
<td>Android 安全补丁程序级别</td>
</tr>
<tr>
<td>ro.product.model</td>
<td>型号</td>
</tr>
<tr>
<td>ro.product.brand</td>
<td>品牌</td>
</tr>
<tr>
<td>ro.product.name</td>
<td>设备名</td>
</tr>
<tr>
<td>ro.product.board</td>
<td>处理器型号</td>
</tr>
<tr>
<td>ro.product.cpu.abilist</td>
<td>CPU 支持的 abi 列表[<em>节注一</em>]</td>
</tr>
<tr>
<td>persist.sys.isUsbOtgEnabled</td>
<td>是否支持 OTG</td>
</tr>
<tr>
<td>dalvik.vm.heapsize</td>
<td>每个应用程序的内存上限</td>
</tr>
<tr>
<td>ro.sf.lcd_density</td>
<td>屏幕密度</td>
</tr>
</tbody>
</table>
<p><strong>节注一：</strong></p>
<p>一些小厂定制的 ROM 可能修改过 CPU 支持的 abi 列表的属性名，如果用 ro.product.cpu.abilist 属性名查找不到，可以这样试试：</p>
<pre tabindex="0"><code>adb shell cat /system/build.prop | grep ro.product.cpu.abi
1
</code></pre><p>示例输出：</p>
<pre tabindex="0"><code>ro.product.cpu.abi=armeabi-v7a
ro.product.cpu.abi2=armeabi
12
</code></pre><h2 id="修改设置">修改设置</h2>
<p><em>注： 修改设置之后，运行恢复命令有可能显示仍然不太正常，可以运行 adb reboot 重启设备，或手动重启。</em></p>
<p>修改设置的原理主要是通过 settings 命令修改 /data/data/com.android.providers.settings/databases/settings.db 里存放的设置值。</p>
<h3 id="分辨率">分辨率</h3>
<p>命令：</p>
<pre tabindex="0"><code>adb shell wm size 480x1024
1
</code></pre><p>表示将分辨率修改为 480px * 1024px。</p>
<p>恢复原分辨率命令：</p>
<pre tabindex="0"><code>adb shell wm size reset
1
</code></pre><h3 id="屏幕密度-1">屏幕密度</h3>
<p>命令：</p>
<pre tabindex="0"><code>adb shell wm density 160
1
</code></pre><p>表示将屏幕密度修改为 160dpi。</p>
<p>恢复原屏幕密度命令：</p>
<pre tabindex="0"><code>adb shell wm density reset
1
</code></pre><h3 id="显示区域">显示区域</h3>
<p>命令：</p>
<pre tabindex="0"><code>adb shell wm overscan 0,0,0,200
1
</code></pre><p>四个数字分别表示距离左、上、右、下边缘的留白像素，以上命令表示将屏幕底部 200px 留白。</p>
<p>恢复原显示区域命令：</p>
<pre tabindex="0"><code>adb shell wm overscan reset
1
</code></pre><h3 id="关闭-usb-调试模式">关闭 USB 调试模式</h3>
<p>命令：</p>
<p>adb shell settings put global adb_enabled 0
恢复：</p>
<p>用命令恢复不了了，毕竟关闭了 USB 调试 adb 就连接不上 Android 设备了。</p>
<p>去设备上手动恢复吧：「设置」-「开发者选项」-「Android 调试」。</p>
<h3 id="状态栏和导航栏的显示隐藏">状态栏和导航栏的显示隐藏</h3>
<p>本节所说的相关设置对应 Cyanogenmod 里的「扩展桌面」。</p>
<p>命令：</p>
<pre tabindex="0"><code>adb shell settings put global policy_control &lt;key-values&gt;
1
</code></pre><p><code>&lt;key-values&gt;</code> 可由如下几种键及其对应的值组成，格式为 <code>&lt;key1&gt;=&lt;value1&gt;:&lt;key2&gt;=&lt;value2&gt;</code>。</p>
<table>
<thead>
<tr>
<th>key</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>immersive.full</td>
<td>同时隐藏</td>
</tr>
<tr>
<td>immersive.status</td>
<td>隐藏状态栏</td>
</tr>
<tr>
<td>immersive.navigation</td>
<td>隐藏导航栏</td>
</tr>
<tr>
<td>immersive.preconfirms</td>
<td>?</td>
</tr>
</tbody>
</table>
<p>这些键对应的值可则如下值用逗号组合：</p>
<table>
<thead>
<tr>
<th>value</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>apps</code></td>
<td>所有应用</td>
</tr>
<tr>
<td><code>*</code></td>
<td>所有界面</td>
</tr>
<tr>
<td><code>packagename</code></td>
<td>指定应用</td>
</tr>
<tr>
<td><code>-packagename</code></td>
<td>排除指定应用</td>
</tr>
</tbody>
</table>
<p>例如：</p>
<pre tabindex="0"><code>adb shell settings put global policy_control immersive.full=*
1
</code></pre><p>表示设置在所有界面下都同时隐藏状态栏和导航栏。</p>
<pre tabindex="0"><code>adb shell settings put global policy_control immersive.status=com.package1,com.package2:immersive.navigation=apps,-com.package3
1
</code></pre><p>表示设置在包名为 com.package1 和 com.package2 的应用里隐藏状态栏，在除了包名为 com.package3 的所有应用里隐藏导航栏。</p>
<h3 id="恢复正常模式">恢复正常模式</h3>
<p>不想全屏了咋办呢？</p>
<pre tabindex="0"><code>adb shell settings put global policy_control null
1
</code></pre><h2 id="实用功能">实用功能</h2>
<h3 id="屏幕截图">屏幕截图</h3>
<p><strong>截图保存到电脑：</strong></p>
<pre tabindex="0"><code>adb exec-out screencap -p &gt; sc.png
1
</code></pre><p>如果 adb 版本较老，无法使用 exec-out 命令，这时候建议更新 adb 版本。无法更新的话可以使用以下麻烦点的办法：</p>
<p>先截图保存到设备里：</p>
<pre tabindex="0"><code>adb shell screencap -p /sdcard/sc.png
1
</code></pre><p>然后将 png 文件导出到电脑：</p>
<pre tabindex="0"><code>adb pull /sdcard/sc.png
1
</code></pre><p>可以使用 adb shell screencap -h 查看 screencap 命令的帮助信息，下面是两个有意义的参数及含义：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>-p</td>
<td>指定保存文件为 png 格式</td>
</tr>
<tr>
<td>-d display-id</td>
<td>指定截图的显示屏编号（有多显示屏的情况下）</td>
</tr>
</tbody>
</table>
<p>实测如果指定文件名以 .png 结尾时可以省略 -p 参数；否则需要使用 -p 参数。如果不指定文件名，截图文件的内容将直接输出到 stdout。</p>
<p><strong>另外一种一行命令截图并保存到电脑的方法：</strong></p>
<p>Linux 和 Windows</p>
<pre tabindex="0"><code>adb shell screencap -p | sed &#34;s/\r$//&#34; &gt; sc.png
1
</code></pre><p>Mac OS X</p>
<pre tabindex="0"><code>adb shell screencap -p | gsed &#34;s/\r$//&#34; &gt; sc.png
1
</code></pre><p>这个方法需要用到 gnu sed 命令，在 Linux 下直接就有，在 Windows 下 Git 安装目录的 bin 文件夹下也有。如果确实找不到该命令，可以下载 sed for Windows 并将 sed.exe 所在文件夹添加到 PATH 环境变量里。</p>
<p>而在 Mac 下使用系统自带的 sed 命令会报错：</p>
<pre tabindex="0"><code>sed: RE error: illegal byte sequence
1
</code></pre><p>需要安装 gnu-sed，然后使用 gsed 命令：</p>
<pre tabindex="0"><code>brew install gnu-sed
1
</code></pre><h3 id="录制屏幕">录制屏幕</h3>
<p>录制屏幕以 mp4 格式保存到 /sdcard：</p>
<pre tabindex="0"><code>adb shell screenrecord /sdcard/filename.mp4
1
</code></pre><p>需要停止时按 Ctrl-C，默认录制时间和最长录制时间都是 180 秒。</p>
<p>如果需要导出到电脑：</p>
<pre tabindex="0"><code>adb pull /sdcard/filename.mp4
1
</code></pre><p>可以使用 adb shell screenrecord &ndash;help 查看 screenrecord 命令的帮助信息，下面是常见参数及含义：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>&ndash;size WIDTHxHEIGHT</td>
<td>视频的尺寸，比如 <code>1280x720</code>，默认是屏幕分辨率。</td>
</tr>
<tr>
<td>&ndash;bit-rate RATE</td>
<td>视频的比特率，默认是 4Mbps。</td>
</tr>
<tr>
<td>&ndash;time-limit TIME</td>
<td>录制时长，单位秒。</td>
</tr>
<tr>
<td>&ndash;verbose</td>
<td>输出更多信息。</td>
</tr>
</tbody>
</table>
<p><strong>重新挂载 system 分区为可写</strong></p>
<p><em>注：需要 root 权限。</em></p>
<p>/system 分区默认挂载为只读，但有些操作比如给 Android 系统添加命令、删除自带应用等需要对 /system 进行写操作，所以需要重新挂载它为可读写。</p>
<p>步骤：</p>
<p>进入 shell 并切换到 root 用户权限。</p>
<p>命令：</p>
<pre tabindex="0"><code>adb shell
su
12
</code></pre><p>查看当前分区挂载情况。</p>
<p>命令：</p>
<pre tabindex="0"><code>mount
1
</code></pre><p>输出示例：</p>
<pre tabindex="0"><code>rootfs / rootfs ro,relatime 0 0
tmpfs /dev tmpfs rw,seclabel,nosuid,relatime,mode=755 0 0
devpts /dev/pts devpts rw,seclabel,relatime,mode=600 0 0
proc /proc proc rw,relatime 0 0
sysfs /sys sysfs rw,seclabel,relatime 0 0
selinuxfs /sys/fs/selinux selinuxfs rw,relatime 0 0
debugfs /sys/kernel/debug debugfs rw,relatime 0 0
none /var tmpfs rw,seclabel,relatime,mode=770,gid=1000 0 0
none /acct cgroup rw,relatime,cpuacct 0 0
none /sys/fs/cgroup tmpfs rw,seclabel,relatime,mode=750,gid=1000 0 0
none /sys/fs/cgroup/memory cgroup rw,relatime,memory 0 0
tmpfs /mnt/asec tmpfs rw,seclabel,relatime,mode=755,gid=1000 0 0
tmpfs /mnt/obb tmpfs rw,seclabel,relatime,mode=755,gid=1000 0 0
none /dev/memcg cgroup rw,relatime,memory 0 0
none /dev/cpuctl cgroup rw,relatime,cpu 0 0
none /sys/fs/cgroup tmpfs rw,seclabel,relatime,mode=750,gid=1000 0 0
none /sys/fs/cgroup/memory cgroup rw,relatime,memory 0 0
none /sys/fs/cgroup/freezer cgroup rw,relatime,freezer 0 0
/dev/block/platform/msm_sdcc.1/by-name/system /system ext4 ro,seclabel,relatime,data=ordered 0 0
/dev/block/platform/msm_sdcc.1/by-name/userdata /data ext4 rw,seclabel,nosuid,nodev,relatime,noauto_da_alloc,data=ordered 0 0
/dev/block/platform/msm_sdcc.1/by-name/cache /cache ext4 rw,seclabel,nosuid,nodev,relatime,data=ordered 0 0
/dev/block/platform/msm_sdcc.1/by-name/persist /persist ext4 rw,seclabel,nosuid,nodev,relatime,data=ordered 0 0
/dev/block/platform/msm_sdcc.1/by-name/modem /firmware vfat ro,context=u:object_r:firmware_file:s0,relatime,uid=1000,gid=1000,fmask=0337,dmask=0227,codepage=cp437,iocharset=iso8859-1,shortname=lower,errors=remount-ro 0 0
/dev/fuse /mnt/shell/emulated fuse rw,nosuid,nodev,relatime,user_id=1023,group_id=1023,default_permissions,allow_other 0 0
/dev/fuse /mnt/shell/emulated/0 fuse rw,nosuid,nodev,relatime,user_id=1023,group_id=1023,default_permissions,allow_other 0 0
12345678910111213141516171819202122232425
</code></pre><p>找到其中我们关注的带 /system 的那一行：</p>
<pre tabindex="0"><code>/dev/block/platform/msm_sdcc.1/by-name/system /system ext4 ro,seclabel,relatime,data=ordered 0 0
1
</code></pre><h3 id="重新挂载">重新挂载。</h3>
<p>命令：</p>
<pre tabindex="0"><code>mount -o remount,rw -t yaffs2 /dev/block/platform/msm_sdcc.1/by-name/system /system
1
</code></pre><p>这里的 /dev/block/platform/msm_sdcc.1/by-name/system 就是我们从上一步的输出里得到的文件路径。</p>
<p>如果输出没有提示错误的话，操作就成功了，可以对 /system 下的文件为所欲为了。</p>
<h3 id="查看连接过的-wifi-密码">查看连接过的 WiFi 密码</h3>
<p><em>注：需要 root 权限。</em></p>
<p>命令：</p>
<pre tabindex="0"><code>adb shell
su
cat /data/misc/wifi/*.conf
123
</code></pre><p>输出示例：</p>
<pre tabindex="0"><code>network={
	ssid=&#34;TP-LINK_9DFC&#34;
	scan_ssid=1
	psk=&#34;123456789&#34;
	key_mgmt=WPA-PSK
	group=CCMP TKIP
	auth_alg=OPEN
	sim_num=1
	priority=13893
}

network={
	ssid=&#34;TP-LINK_F11E&#34;
	psk=&#34;987654321&#34;
	key_mgmt=WPA-PSK
	sim_num=1
	priority=17293
}
123456789101112131415161718
</code></pre><p>ssid 即为我们在 WLAN 设置里看到的名称，psk 为密码，key_mgmt 为安全加密方式。</p>
<h3 id="设置系统日期和时间">设置系统日期和时间</h3>
<p><em>注：需要 root 权限。</em></p>
<p>命令：</p>
<pre tabindex="0"><code>adb shell
su
date -s 20160823.131500
123
</code></pre><p>表示将系统日期和时间更改为 2016 年 08 月 23 日 13 点 15 分 00 秒。</p>
<h3 id="重启手机">重启手机</h3>
<p>命令：</p>
<pre tabindex="0"><code>adb reboot
1
</code></pre><h3 id="检测设备是否已-root">检测设备是否已 root</h3>
<p>命令：</p>
<pre tabindex="0"><code>adb shell
su
12
</code></pre><p>此时命令行提示符是 $ 则表示没有 root 权限，是 # 则表示已 root。</p>
<h3 id="使用-monkey-进行压力测试">使用 Monkey 进行压力测试</h3>
<p>Monkey 可以生成伪随机用户事件来模拟单击、触摸、手势等操作，可以对正在开发中的程序进行随机压力测试。</p>
<p>简单用法：</p>
<pre tabindex="0"><code>adb shell monkey -p &lt;packagename&gt; -v 500
1
</code></pre><p>表示向 <code>&lt;packagename&gt;</code> 指定的应用程序发送 500 个伪随机事件。</p>
<p>Monkey 的详细用法参考 官方文档。</p>
<h3 id="开启关闭-wifi">开启/关闭 WiFi</h3>
<p>注：需要 root 权限。</p>
<p>有时需要控制设备的 WiFi 状态，可以用以下指令完成。</p>
<p>开启 WiFi：</p>
<pre tabindex="0"><code>adb root
adb shell svc wifi enable
12
</code></pre><p>关闭 WiFi：</p>
<pre tabindex="0"><code>adb root
adb shell svc wifi disable
12
</code></pre><p>若执行成功，输出为空；若未取得 root 权限执行此命令，将执行失败，输出 Killed。</p>
<h2 id="刷机相关命令">刷机相关命令</h2>
<h3 id="重启到-recovery-模式">重启到 Recovery 模式</h3>
<p>命令：</p>
<pre tabindex="0"><code>adb reboot recovery
1
</code></pre><h3 id="从-recovery-重启到-android">从 Recovery 重启到 Android</h3>
<p>命令：</p>
<pre tabindex="0"><code>adb reboot
1
</code></pre><h3 id="重启到-fastboot-模式">重启到 Fastboot 模式</h3>
<p>命令：</p>
<pre tabindex="0"><code>adb reboot bootloader
1
</code></pre><h3 id="通过-sideload-更新系统">通过 sideload 更新系统</h3>
<p>如果我们下载了 Android 设备对应的系统更新包到电脑上，那么也可以通过 adb 来完成更新。</p>
<p>以 Recovery 模式下更新为例：</p>
<p>重启到 Recovery 模式。</p>
<p>命令：</p>
<pre tabindex="0"><code>adb reboot recovery
1
</code></pre><p>在设备的 Recovery 界面上操作进入 Apply update-Apply from ADB。</p>
<p><em>注：不同的 Recovery 菜单可能与此有差异，有的是一级菜单就有 Apply update from ADB。</em></p>
<p><strong>通过 adb 上传和更新系统。</strong></p>
<p>命令：</p>
<pre tabindex="0"><code>adb sideload &lt;path-to-update.zip&gt;
1
</code></pre><h3 id="更多-adb-shell-命令">更多 adb shell 命令</h3>
<p>Android 系统是基于 Linux 内核的，所以 Linux 里的很多命令在 Android 里也有相同或类似的实现，在 adb shell 里可以调用。本文档前面的部分内容已经用到了 adb shell 命令。</p>
<h3 id="查看进程">查看进程</h3>
<pre tabindex="0"><code>adb shell ps
1
</code></pre><p>例：</p>
<pre tabindex="0"><code>USER     PID   PPID  VSIZE  RSS     WCHAN    PC        NAME
root      1     0     8904   788   ffffffff 00000000 S /init
root      2     0     0      0     ffffffff 00000000 S kthreadd
...
u0_a71    7779  5926  1538748 48896 ffffffff 00000000 S com.sohu.inputmethod.sogou:classic
u0_a58    7963  5926  1561916 59568 ffffffff 00000000 S org.mazhuang.boottimemeasure
...
shell     8750  217   10640  740   00000000 b6f28340 R ps
12345678
</code></pre><p>各列含义：</p>
<table>
<thead>
<tr>
<th>列名</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>USER</td>
<td>所属用户</td>
</tr>
<tr>
<td>PID</td>
<td>进程 ID</td>
</tr>
<tr>
<td>PPID</td>
<td>父进程 ID</td>
</tr>
<tr>
<td>NAME</td>
<td>进程名</td>
</tr>
</tbody>
</table>
<h3 id="查看实时资源占用情况">查看实时资源占用情况</h3>
<pre tabindex="0"><code>adb shell top
1
</code></pre><p>例：</p>
<pre tabindex="0"><code>User 0%, System 6%, IOW 0%, IRQ 0%
User 3 + Nice 0 + Sys 21 + Idle 280 + IOW 0 + IRQ 0 + SIRQ 3 = 307

  PID PR CPU% S  #THR     VSS     RSS PCY UID      Name
 8763  0   3% R     1  10640K   1064K  fg shell    top
  131  0   3% S     1      0K      0K  fg root     dhd_dpc
 6144  0   0% S   115 1682004K 115916K  fg system   system_server
  132  0   0% S     1      0K      0K  fg root     dhd_rxf
 1731  0   0% S     6  20288K    788K  fg root     /system/bin/mpdecision
  217  0   0% S     6  18008K    356K  fg shell    /sbin/adbd
 ...
 7779  2   0% S    19 1538748K  48896K  bg u0_a71   com.sohu.inputmethod.sogou:classic
 7963  0   0% S    18 1561916K  59568K  fg u0_a58   org.mazhuang.boottimemeasure
 ...
1234567891011121314
</code></pre><p>各列含义：</p>
<table>
<thead>
<tr>
<th>列名</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>PID</td>
<td>进程 ID</td>
</tr>
<tr>
<td>PR</td>
<td>优先级</td>
</tr>
<tr>
<td>CPU%</td>
<td>当前瞬间占用 CPU 百分比</td>
</tr>
<tr>
<td>S</td>
<td>进程状态（R=运行，S=睡眠，T=跟踪/停止，Z=僵尸进程）</td>
</tr>
<tr>
<td>#THR</td>
<td>线程数</td>
</tr>
<tr>
<td>VSS</td>
<td>Virtual Set Size 虚拟耗用内存（包含共享库占用的内存）</td>
</tr>
<tr>
<td>RSS</td>
<td>Resident Set Size 实际使用物理内存（包含共享库占用的内存）</td>
</tr>
<tr>
<td>PCY</td>
<td>调度策略优先级，SP_BACKGROUND/SPFOREGROUND</td>
</tr>
<tr>
<td>UID</td>
<td>进程所有者的用户 ID</td>
</tr>
<tr>
<td>NAME</td>
<td>进程名</td>
</tr>
</tbody>
</table>
<p>top 命令还支持一些命令行参数，详细用法如下：</p>
<pre tabindex="0"><code>Usage: top [ -m max_procs ] [ -n iterations ] [ -d delay ] [ -s sort_column ] [ -t ] [ -h ]
    -m num  最多显示多少个进程
    -n num  刷新多少次后退出
    -d num  刷新时间间隔（单位秒，默认值 5）
    -s col  按某列排序（可用 col 值：cpu, vss, rss, thr）
    -t      显示线程信息
    -h      显示帮助文档
1234567
</code></pre><h3 id="查看进程-uid">查看进程 UID</h3>
<p>有两种方案：</p>
<pre tabindex="0"><code>adb shell dumpsys package &lt;packagename&gt; | grep userId=
1
</code></pre><p>如：</p>
<pre tabindex="0"><code>$ adb shell dumpsys package org.mazhuang.guanggoo | grep userId=
   userId=10394
12
</code></pre><p>通过 ps 命令找到对应进程的 pid 之后 <code>adb shell cat /proc/&lt;pid&gt;/status | grep Uid</code></p>
<p>如：</p>
<pre tabindex="0"><code>$ adb shell
gemini:/ $ ps | grep org.mazhuang.guanggoo
u0_a394   28635 770   1795812 78736 SyS_epoll_ 0000000000 S org.mazhuang.guanggoo
gemini:/ $ cat /proc/28635/status | grep Uid
Uid:    10394   10394   10394   10394
gemini:/ $
123456
</code></pre><h3 id="其它">其它</h3>
<p>如下是其它常用命令的简单描述，前文已经专门讲过的命令不再额外说明：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>cat</td>
<td>显示文件内容</td>
</tr>
<tr>
<td>cd</td>
<td>切换目录</td>
</tr>
<tr>
<td>chmod</td>
<td>改变文件的存取模式/访问权限</td>
</tr>
<tr>
<td>df</td>
<td>查看磁盘空间使用情况</td>
</tr>
<tr>
<td>grep</td>
<td>过滤输出</td>
</tr>
<tr>
<td>kill</td>
<td>杀死指定 PID 的进程</td>
</tr>
<tr>
<td>ls</td>
<td>列举目录内容</td>
</tr>
<tr>
<td>mount</td>
<td>挂载目录的查看和管理</td>
</tr>
<tr>
<td>mv</td>
<td>移动或重命名文件</td>
</tr>
<tr>
<td>ps</td>
<td>查看正在运行的进程</td>
</tr>
<tr>
<td>rm</td>
<td>删除文件</td>
</tr>
<tr>
<td>top</td>
<td>查看进程的资源占用情况</td>
</tr>
</tbody>
</table>
<h2 id="常见问题">常见问题</h2>
<h3 id="启动-adb-server-失败">启动 adb server 失败</h3>
<p>出错提示</p>
<pre tabindex="0"><code>error: protocol fault (couldn&#39;t read status): No error
1
</code></pre><p>可能原因</p>
<p>adb server 进程想使用的 5037 端口被占用。</p>
<p>解决方案</p>
<p>找到占用 5037 端口的进程，然后终止它。以 Windows 下为例：</p>
<pre tabindex="0"><code>netstat -ano | findstr LISTENING

...
TCP    0.0.0.0:5037           0.0.0.0:0              LISTENING       1548
...
12345
</code></pre><p>这里 1548 即为进程 ID，用命令结束该进程：</p>
<pre tabindex="0"><code>taskkill /PID 1548
1
</code></pre><p>然后再启动 adb 就没问题了。</p>
</section>

  
  

  
  
  
  <nav class="mt-24 flex rounded-lg bg-black/[3%] text-lg dark:bg-white/[8%]">
    
    
    <a
      class="ml-auto flex w-1/2 items-center justify-end p-6 pl-3 no-underline"
      href="http://localhost/posts/docker-commands/"
      ><span>Docker 命令大全</span><span class="ml-1.5">→</span></a
    >
    
  </nav>
  

  
  
</article>


    </main>

    <footer
  class="opaco mx-auto flex h-[5rem] max-w-3xl items-center px-8 text-[0.9em] opacity-60"
>
  <div class="mr-auto">
    &copy; 2022
    <a class="link" href="http://localhost/">My Docs</a>
  </div>
  <a class="link mx-6" href="https://gohugo.io/" rel="noopener" target="_blank"
    >Powered by Hugo️️</a
  >️
  <a
    class="link"
    href="https://github.com/nanxiaobei/hugo-paper"
    rel="noopener"
    target="_blank"
    >▷ Paper 6</a
  >
</footer>

  </body>
</html>
